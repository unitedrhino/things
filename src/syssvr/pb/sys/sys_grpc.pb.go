// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.19.4
// source: proto/sys.proto

package sys

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// UserClient is the client API for User service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UserClient interface {
	UserCreate(ctx context.Context, in *UserInfo, opts ...grpc.CallOption) (*UserCreateResp, error)
	UserIndex(ctx context.Context, in *UserIndexReq, opts ...grpc.CallOption) (*UserIndexResp, error)
	UserUpdate(ctx context.Context, in *UserInfo, opts ...grpc.CallOption) (*Response, error)
	UserRead(ctx context.Context, in *UserReadReq, opts ...grpc.CallOption) (*UserInfo, error)
	UserDelete(ctx context.Context, in *UserDeleteReq, opts ...grpc.CallOption) (*Response, error)
	UserLogin(ctx context.Context, in *UserLoginReq, opts ...grpc.CallOption) (*UserLoginResp, error)
	UserCheckToken(ctx context.Context, in *UserCheckTokenReq, opts ...grpc.CallOption) (*UserCheckTokenResp, error)
	UserRegister1(ctx context.Context, in *UserRegister1Req, opts ...grpc.CallOption) (*UserRegister1Resp, error)
	UserRegister2(ctx context.Context, in *UserRegister2Req, opts ...grpc.CallOption) (*Response, error)
	UserAuthProjectMultiUpdate(ctx context.Context, in *UserAuthProjectMultiUpdateReq, opts ...grpc.CallOption) (*Response, error)
	UserAuthProjectIndex(ctx context.Context, in *UserAuthProjectIndexReq, opts ...grpc.CallOption) (*UserAuthProjectIndexResp, error)
	UserAuthAreaMultiUpdate(ctx context.Context, in *UserAuthAreaMultiUpdateReq, opts ...grpc.CallOption) (*Response, error)
	UserAuthAreaIndex(ctx context.Context, in *UserAuthAreaIndexReq, opts ...grpc.CallOption) (*UserAuthAreaIndexResp, error)
}

type userClient struct {
	cc grpc.ClientConnInterface
}

func NewUserClient(cc grpc.ClientConnInterface) UserClient {
	return &userClient{cc}
}

func (c *userClient) UserCreate(ctx context.Context, in *UserInfo, opts ...grpc.CallOption) (*UserCreateResp, error) {
	out := new(UserCreateResp)
	err := c.cc.Invoke(ctx, "/sys.User/userCreate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) UserIndex(ctx context.Context, in *UserIndexReq, opts ...grpc.CallOption) (*UserIndexResp, error) {
	out := new(UserIndexResp)
	err := c.cc.Invoke(ctx, "/sys.User/userIndex", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) UserUpdate(ctx context.Context, in *UserInfo, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/sys.User/userUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) UserRead(ctx context.Context, in *UserReadReq, opts ...grpc.CallOption) (*UserInfo, error) {
	out := new(UserInfo)
	err := c.cc.Invoke(ctx, "/sys.User/userRead", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) UserDelete(ctx context.Context, in *UserDeleteReq, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/sys.User/userDelete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) UserLogin(ctx context.Context, in *UserLoginReq, opts ...grpc.CallOption) (*UserLoginResp, error) {
	out := new(UserLoginResp)
	err := c.cc.Invoke(ctx, "/sys.User/userLogin", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) UserCheckToken(ctx context.Context, in *UserCheckTokenReq, opts ...grpc.CallOption) (*UserCheckTokenResp, error) {
	out := new(UserCheckTokenResp)
	err := c.cc.Invoke(ctx, "/sys.User/userCheckToken", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) UserRegister1(ctx context.Context, in *UserRegister1Req, opts ...grpc.CallOption) (*UserRegister1Resp, error) {
	out := new(UserRegister1Resp)
	err := c.cc.Invoke(ctx, "/sys.User/userRegister1", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) UserRegister2(ctx context.Context, in *UserRegister2Req, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/sys.User/userRegister2", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) UserAuthProjectMultiUpdate(ctx context.Context, in *UserAuthProjectMultiUpdateReq, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/sys.User/userAuthProjectMultiUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) UserAuthProjectIndex(ctx context.Context, in *UserAuthProjectIndexReq, opts ...grpc.CallOption) (*UserAuthProjectIndexResp, error) {
	out := new(UserAuthProjectIndexResp)
	err := c.cc.Invoke(ctx, "/sys.User/userAuthProjectIndex", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) UserAuthAreaMultiUpdate(ctx context.Context, in *UserAuthAreaMultiUpdateReq, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/sys.User/userAuthAreaMultiUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userClient) UserAuthAreaIndex(ctx context.Context, in *UserAuthAreaIndexReq, opts ...grpc.CallOption) (*UserAuthAreaIndexResp, error) {
	out := new(UserAuthAreaIndexResp)
	err := c.cc.Invoke(ctx, "/sys.User/userAuthAreaIndex", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserServer is the server API for User service.
// All implementations must embed UnimplementedUserServer
// for forward compatibility
type UserServer interface {
	UserCreate(context.Context, *UserInfo) (*UserCreateResp, error)
	UserIndex(context.Context, *UserIndexReq) (*UserIndexResp, error)
	UserUpdate(context.Context, *UserInfo) (*Response, error)
	UserRead(context.Context, *UserReadReq) (*UserInfo, error)
	UserDelete(context.Context, *UserDeleteReq) (*Response, error)
	UserLogin(context.Context, *UserLoginReq) (*UserLoginResp, error)
	UserCheckToken(context.Context, *UserCheckTokenReq) (*UserCheckTokenResp, error)
	UserRegister1(context.Context, *UserRegister1Req) (*UserRegister1Resp, error)
	UserRegister2(context.Context, *UserRegister2Req) (*Response, error)
	UserAuthProjectMultiUpdate(context.Context, *UserAuthProjectMultiUpdateReq) (*Response, error)
	UserAuthProjectIndex(context.Context, *UserAuthProjectIndexReq) (*UserAuthProjectIndexResp, error)
	UserAuthAreaMultiUpdate(context.Context, *UserAuthAreaMultiUpdateReq) (*Response, error)
	UserAuthAreaIndex(context.Context, *UserAuthAreaIndexReq) (*UserAuthAreaIndexResp, error)
	mustEmbedUnimplementedUserServer()
}

// UnimplementedUserServer must be embedded to have forward compatible implementations.
type UnimplementedUserServer struct {
}

func (UnimplementedUserServer) UserCreate(context.Context, *UserInfo) (*UserCreateResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserCreate not implemented")
}
func (UnimplementedUserServer) UserIndex(context.Context, *UserIndexReq) (*UserIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserIndex not implemented")
}
func (UnimplementedUserServer) UserUpdate(context.Context, *UserInfo) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserUpdate not implemented")
}
func (UnimplementedUserServer) UserRead(context.Context, *UserReadReq) (*UserInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserRead not implemented")
}
func (UnimplementedUserServer) UserDelete(context.Context, *UserDeleteReq) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserDelete not implemented")
}
func (UnimplementedUserServer) UserLogin(context.Context, *UserLoginReq) (*UserLoginResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserLogin not implemented")
}
func (UnimplementedUserServer) UserCheckToken(context.Context, *UserCheckTokenReq) (*UserCheckTokenResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserCheckToken not implemented")
}
func (UnimplementedUserServer) UserRegister1(context.Context, *UserRegister1Req) (*UserRegister1Resp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserRegister1 not implemented")
}
func (UnimplementedUserServer) UserRegister2(context.Context, *UserRegister2Req) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserRegister2 not implemented")
}
func (UnimplementedUserServer) UserAuthProjectMultiUpdate(context.Context, *UserAuthProjectMultiUpdateReq) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserAuthProjectMultiUpdate not implemented")
}
func (UnimplementedUserServer) UserAuthProjectIndex(context.Context, *UserAuthProjectIndexReq) (*UserAuthProjectIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserAuthProjectIndex not implemented")
}
func (UnimplementedUserServer) UserAuthAreaMultiUpdate(context.Context, *UserAuthAreaMultiUpdateReq) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserAuthAreaMultiUpdate not implemented")
}
func (UnimplementedUserServer) UserAuthAreaIndex(context.Context, *UserAuthAreaIndexReq) (*UserAuthAreaIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserAuthAreaIndex not implemented")
}
func (UnimplementedUserServer) mustEmbedUnimplementedUserServer() {}

// UnsafeUserServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserServer will
// result in compilation errors.
type UnsafeUserServer interface {
	mustEmbedUnimplementedUserServer()
}

func RegisterUserServer(s grpc.ServiceRegistrar, srv UserServer) {
	s.RegisterService(&User_ServiceDesc, srv)
}

func _User_UserCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).UserCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sys.User/userCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).UserCreate(ctx, req.(*UserInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_UserIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).UserIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sys.User/userIndex",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).UserIndex(ctx, req.(*UserIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_UserUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).UserUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sys.User/userUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).UserUpdate(ctx, req.(*UserInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_UserRead_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserReadReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).UserRead(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sys.User/userRead",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).UserRead(ctx, req.(*UserReadReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_UserDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserDeleteReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).UserDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sys.User/userDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).UserDelete(ctx, req.(*UserDeleteReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_UserLogin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserLoginReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).UserLogin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sys.User/userLogin",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).UserLogin(ctx, req.(*UserLoginReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_UserCheckToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserCheckTokenReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).UserCheckToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sys.User/userCheckToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).UserCheckToken(ctx, req.(*UserCheckTokenReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_UserRegister1_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserRegister1Req)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).UserRegister1(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sys.User/userRegister1",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).UserRegister1(ctx, req.(*UserRegister1Req))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_UserRegister2_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserRegister2Req)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).UserRegister2(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sys.User/userRegister2",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).UserRegister2(ctx, req.(*UserRegister2Req))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_UserAuthProjectMultiUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserAuthProjectMultiUpdateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).UserAuthProjectMultiUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sys.User/userAuthProjectMultiUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).UserAuthProjectMultiUpdate(ctx, req.(*UserAuthProjectMultiUpdateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_UserAuthProjectIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserAuthProjectIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).UserAuthProjectIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sys.User/userAuthProjectIndex",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).UserAuthProjectIndex(ctx, req.(*UserAuthProjectIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_UserAuthAreaMultiUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserAuthAreaMultiUpdateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).UserAuthAreaMultiUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sys.User/userAuthAreaMultiUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).UserAuthAreaMultiUpdate(ctx, req.(*UserAuthAreaMultiUpdateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _User_UserAuthAreaIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserAuthAreaIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserServer).UserAuthAreaIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sys.User/userAuthAreaIndex",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserServer).UserAuthAreaIndex(ctx, req.(*UserAuthAreaIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

// User_ServiceDesc is the grpc.ServiceDesc for User service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var User_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sys.User",
	HandlerType: (*UserServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "userCreate",
			Handler:    _User_UserCreate_Handler,
		},
		{
			MethodName: "userIndex",
			Handler:    _User_UserIndex_Handler,
		},
		{
			MethodName: "userUpdate",
			Handler:    _User_UserUpdate_Handler,
		},
		{
			MethodName: "userRead",
			Handler:    _User_UserRead_Handler,
		},
		{
			MethodName: "userDelete",
			Handler:    _User_UserDelete_Handler,
		},
		{
			MethodName: "userLogin",
			Handler:    _User_UserLogin_Handler,
		},
		{
			MethodName: "userCheckToken",
			Handler:    _User_UserCheckToken_Handler,
		},
		{
			MethodName: "userRegister1",
			Handler:    _User_UserRegister1_Handler,
		},
		{
			MethodName: "userRegister2",
			Handler:    _User_UserRegister2_Handler,
		},
		{
			MethodName: "userAuthProjectMultiUpdate",
			Handler:    _User_UserAuthProjectMultiUpdate_Handler,
		},
		{
			MethodName: "userAuthProjectIndex",
			Handler:    _User_UserAuthProjectIndex_Handler,
		},
		{
			MethodName: "userAuthAreaMultiUpdate",
			Handler:    _User_UserAuthAreaMultiUpdate_Handler,
		},
		{
			MethodName: "userAuthAreaIndex",
			Handler:    _User_UserAuthAreaIndex_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/sys.proto",
}

// RoleClient is the client API for Role service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RoleClient interface {
	RoleCreate(ctx context.Context, in *RoleCreateReq, opts ...grpc.CallOption) (*Response, error)
	RoleIndex(ctx context.Context, in *RoleIndexReq, opts ...grpc.CallOption) (*RoleIndexResp, error)
	RoleUpdate(ctx context.Context, in *RoleUpdateReq, opts ...grpc.CallOption) (*Response, error)
	RoleDelete(ctx context.Context, in *RoleDeleteReq, opts ...grpc.CallOption) (*Response, error)
	RoleMenuUpdate(ctx context.Context, in *RoleMenuUpdateReq, opts ...grpc.CallOption) (*Response, error)
	RoleApiAuth(ctx context.Context, in *RoleApiAuthReq, opts ...grpc.CallOption) (*Response, error)
	RoleApiMultiUpdate(ctx context.Context, in *RoleApiMultiUpdateReq, opts ...grpc.CallOption) (*Response, error)
	RoleApiIndex(ctx context.Context, in *RoleApiIndexReq, opts ...grpc.CallOption) (*RoleApiIndexResp, error)
}

type roleClient struct {
	cc grpc.ClientConnInterface
}

func NewRoleClient(cc grpc.ClientConnInterface) RoleClient {
	return &roleClient{cc}
}

func (c *roleClient) RoleCreate(ctx context.Context, in *RoleCreateReq, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/sys.Role/roleCreate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleClient) RoleIndex(ctx context.Context, in *RoleIndexReq, opts ...grpc.CallOption) (*RoleIndexResp, error) {
	out := new(RoleIndexResp)
	err := c.cc.Invoke(ctx, "/sys.Role/roleIndex", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleClient) RoleUpdate(ctx context.Context, in *RoleUpdateReq, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/sys.Role/roleUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleClient) RoleDelete(ctx context.Context, in *RoleDeleteReq, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/sys.Role/roleDelete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleClient) RoleMenuUpdate(ctx context.Context, in *RoleMenuUpdateReq, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/sys.Role/roleMenuUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleClient) RoleApiAuth(ctx context.Context, in *RoleApiAuthReq, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/sys.Role/roleApiAuth", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleClient) RoleApiMultiUpdate(ctx context.Context, in *RoleApiMultiUpdateReq, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/sys.Role/roleApiMultiUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleClient) RoleApiIndex(ctx context.Context, in *RoleApiIndexReq, opts ...grpc.CallOption) (*RoleApiIndexResp, error) {
	out := new(RoleApiIndexResp)
	err := c.cc.Invoke(ctx, "/sys.Role/roleApiIndex", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RoleServer is the server API for Role service.
// All implementations must embed UnimplementedRoleServer
// for forward compatibility
type RoleServer interface {
	RoleCreate(context.Context, *RoleCreateReq) (*Response, error)
	RoleIndex(context.Context, *RoleIndexReq) (*RoleIndexResp, error)
	RoleUpdate(context.Context, *RoleUpdateReq) (*Response, error)
	RoleDelete(context.Context, *RoleDeleteReq) (*Response, error)
	RoleMenuUpdate(context.Context, *RoleMenuUpdateReq) (*Response, error)
	RoleApiAuth(context.Context, *RoleApiAuthReq) (*Response, error)
	RoleApiMultiUpdate(context.Context, *RoleApiMultiUpdateReq) (*Response, error)
	RoleApiIndex(context.Context, *RoleApiIndexReq) (*RoleApiIndexResp, error)
	mustEmbedUnimplementedRoleServer()
}

// UnimplementedRoleServer must be embedded to have forward compatible implementations.
type UnimplementedRoleServer struct {
}

func (UnimplementedRoleServer) RoleCreate(context.Context, *RoleCreateReq) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RoleCreate not implemented")
}
func (UnimplementedRoleServer) RoleIndex(context.Context, *RoleIndexReq) (*RoleIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RoleIndex not implemented")
}
func (UnimplementedRoleServer) RoleUpdate(context.Context, *RoleUpdateReq) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RoleUpdate not implemented")
}
func (UnimplementedRoleServer) RoleDelete(context.Context, *RoleDeleteReq) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RoleDelete not implemented")
}
func (UnimplementedRoleServer) RoleMenuUpdate(context.Context, *RoleMenuUpdateReq) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RoleMenuUpdate not implemented")
}
func (UnimplementedRoleServer) RoleApiAuth(context.Context, *RoleApiAuthReq) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RoleApiAuth not implemented")
}
func (UnimplementedRoleServer) RoleApiMultiUpdate(context.Context, *RoleApiMultiUpdateReq) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RoleApiMultiUpdate not implemented")
}
func (UnimplementedRoleServer) RoleApiIndex(context.Context, *RoleApiIndexReq) (*RoleApiIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RoleApiIndex not implemented")
}
func (UnimplementedRoleServer) mustEmbedUnimplementedRoleServer() {}

// UnsafeRoleServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RoleServer will
// result in compilation errors.
type UnsafeRoleServer interface {
	mustEmbedUnimplementedRoleServer()
}

func RegisterRoleServer(s grpc.ServiceRegistrar, srv RoleServer) {
	s.RegisterService(&Role_ServiceDesc, srv)
}

func _Role_RoleCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoleCreateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleServer).RoleCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sys.Role/roleCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleServer).RoleCreate(ctx, req.(*RoleCreateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Role_RoleIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoleIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleServer).RoleIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sys.Role/roleIndex",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleServer).RoleIndex(ctx, req.(*RoleIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Role_RoleUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoleUpdateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleServer).RoleUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sys.Role/roleUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleServer).RoleUpdate(ctx, req.(*RoleUpdateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Role_RoleDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoleDeleteReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleServer).RoleDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sys.Role/roleDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleServer).RoleDelete(ctx, req.(*RoleDeleteReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Role_RoleMenuUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoleMenuUpdateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleServer).RoleMenuUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sys.Role/roleMenuUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleServer).RoleMenuUpdate(ctx, req.(*RoleMenuUpdateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Role_RoleApiAuth_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoleApiAuthReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleServer).RoleApiAuth(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sys.Role/roleApiAuth",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleServer).RoleApiAuth(ctx, req.(*RoleApiAuthReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Role_RoleApiMultiUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoleApiMultiUpdateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleServer).RoleApiMultiUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sys.Role/roleApiMultiUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleServer).RoleApiMultiUpdate(ctx, req.(*RoleApiMultiUpdateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Role_RoleApiIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoleApiIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleServer).RoleApiIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sys.Role/roleApiIndex",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleServer).RoleApiIndex(ctx, req.(*RoleApiIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

// Role_ServiceDesc is the grpc.ServiceDesc for Role service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Role_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sys.Role",
	HandlerType: (*RoleServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "roleCreate",
			Handler:    _Role_RoleCreate_Handler,
		},
		{
			MethodName: "roleIndex",
			Handler:    _Role_RoleIndex_Handler,
		},
		{
			MethodName: "roleUpdate",
			Handler:    _Role_RoleUpdate_Handler,
		},
		{
			MethodName: "roleDelete",
			Handler:    _Role_RoleDelete_Handler,
		},
		{
			MethodName: "roleMenuUpdate",
			Handler:    _Role_RoleMenuUpdate_Handler,
		},
		{
			MethodName: "roleApiAuth",
			Handler:    _Role_RoleApiAuth_Handler,
		},
		{
			MethodName: "roleApiMultiUpdate",
			Handler:    _Role_RoleApiMultiUpdate_Handler,
		},
		{
			MethodName: "roleApiIndex",
			Handler:    _Role_RoleApiIndex_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/sys.proto",
}

// MenuClient is the client API for Menu service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MenuClient interface {
	MenuCreate(ctx context.Context, in *MenuCreateReq, opts ...grpc.CallOption) (*Response, error)
	MenuIndex(ctx context.Context, in *MenuIndexReq, opts ...grpc.CallOption) (*MenuIndexResp, error)
	MenuUpdate(ctx context.Context, in *MenuUpdateReq, opts ...grpc.CallOption) (*Response, error)
	MenuDelete(ctx context.Context, in *MenuDeleteReq, opts ...grpc.CallOption) (*Response, error)
}

type menuClient struct {
	cc grpc.ClientConnInterface
}

func NewMenuClient(cc grpc.ClientConnInterface) MenuClient {
	return &menuClient{cc}
}

func (c *menuClient) MenuCreate(ctx context.Context, in *MenuCreateReq, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/sys.Menu/menuCreate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *menuClient) MenuIndex(ctx context.Context, in *MenuIndexReq, opts ...grpc.CallOption) (*MenuIndexResp, error) {
	out := new(MenuIndexResp)
	err := c.cc.Invoke(ctx, "/sys.Menu/menuIndex", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *menuClient) MenuUpdate(ctx context.Context, in *MenuUpdateReq, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/sys.Menu/menuUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *menuClient) MenuDelete(ctx context.Context, in *MenuDeleteReq, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/sys.Menu/menuDelete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MenuServer is the server API for Menu service.
// All implementations must embed UnimplementedMenuServer
// for forward compatibility
type MenuServer interface {
	MenuCreate(context.Context, *MenuCreateReq) (*Response, error)
	MenuIndex(context.Context, *MenuIndexReq) (*MenuIndexResp, error)
	MenuUpdate(context.Context, *MenuUpdateReq) (*Response, error)
	MenuDelete(context.Context, *MenuDeleteReq) (*Response, error)
	mustEmbedUnimplementedMenuServer()
}

// UnimplementedMenuServer must be embedded to have forward compatible implementations.
type UnimplementedMenuServer struct {
}

func (UnimplementedMenuServer) MenuCreate(context.Context, *MenuCreateReq) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MenuCreate not implemented")
}
func (UnimplementedMenuServer) MenuIndex(context.Context, *MenuIndexReq) (*MenuIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MenuIndex not implemented")
}
func (UnimplementedMenuServer) MenuUpdate(context.Context, *MenuUpdateReq) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MenuUpdate not implemented")
}
func (UnimplementedMenuServer) MenuDelete(context.Context, *MenuDeleteReq) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MenuDelete not implemented")
}
func (UnimplementedMenuServer) mustEmbedUnimplementedMenuServer() {}

// UnsafeMenuServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MenuServer will
// result in compilation errors.
type UnsafeMenuServer interface {
	mustEmbedUnimplementedMenuServer()
}

func RegisterMenuServer(s grpc.ServiceRegistrar, srv MenuServer) {
	s.RegisterService(&Menu_ServiceDesc, srv)
}

func _Menu_MenuCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MenuCreateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MenuServer).MenuCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sys.Menu/menuCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MenuServer).MenuCreate(ctx, req.(*MenuCreateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Menu_MenuIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MenuIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MenuServer).MenuIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sys.Menu/menuIndex",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MenuServer).MenuIndex(ctx, req.(*MenuIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Menu_MenuUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MenuUpdateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MenuServer).MenuUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sys.Menu/menuUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MenuServer).MenuUpdate(ctx, req.(*MenuUpdateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Menu_MenuDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MenuDeleteReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MenuServer).MenuDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sys.Menu/menuDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MenuServer).MenuDelete(ctx, req.(*MenuDeleteReq))
	}
	return interceptor(ctx, in, info, handler)
}

// Menu_ServiceDesc is the grpc.ServiceDesc for Menu service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Menu_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sys.Menu",
	HandlerType: (*MenuServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "menuCreate",
			Handler:    _Menu_MenuCreate_Handler,
		},
		{
			MethodName: "menuIndex",
			Handler:    _Menu_MenuIndex_Handler,
		},
		{
			MethodName: "menuUpdate",
			Handler:    _Menu_MenuUpdate_Handler,
		},
		{
			MethodName: "menuDelete",
			Handler:    _Menu_MenuDelete_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/sys.proto",
}

// CommonClient is the client API for Common service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CommonClient interface {
	Config(ctx context.Context, in *Response, opts ...grpc.CallOption) (*ConfigResp, error)
}

type commonClient struct {
	cc grpc.ClientConnInterface
}

func NewCommonClient(cc grpc.ClientConnInterface) CommonClient {
	return &commonClient{cc}
}

func (c *commonClient) Config(ctx context.Context, in *Response, opts ...grpc.CallOption) (*ConfigResp, error) {
	out := new(ConfigResp)
	err := c.cc.Invoke(ctx, "/sys.Common/config", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CommonServer is the server API for Common service.
// All implementations must embed UnimplementedCommonServer
// for forward compatibility
type CommonServer interface {
	Config(context.Context, *Response) (*ConfigResp, error)
	mustEmbedUnimplementedCommonServer()
}

// UnimplementedCommonServer must be embedded to have forward compatible implementations.
type UnimplementedCommonServer struct {
}

func (UnimplementedCommonServer) Config(context.Context, *Response) (*ConfigResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Config not implemented")
}
func (UnimplementedCommonServer) mustEmbedUnimplementedCommonServer() {}

// UnsafeCommonServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CommonServer will
// result in compilation errors.
type UnsafeCommonServer interface {
	mustEmbedUnimplementedCommonServer()
}

func RegisterCommonServer(s grpc.ServiceRegistrar, srv CommonServer) {
	s.RegisterService(&Common_ServiceDesc, srv)
}

func _Common_Config_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Response)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommonServer).Config(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sys.Common/config",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommonServer).Config(ctx, req.(*Response))
	}
	return interceptor(ctx, in, info, handler)
}

// Common_ServiceDesc is the grpc.ServiceDesc for Common service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Common_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sys.Common",
	HandlerType: (*CommonServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "config",
			Handler:    _Common_Config_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/sys.proto",
}

// LogClient is the client API for Log service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type LogClient interface {
	LoginLogIndex(ctx context.Context, in *LoginLogIndexReq, opts ...grpc.CallOption) (*LoginLogIndexResp, error)
	OperLogIndex(ctx context.Context, in *OperLogIndexReq, opts ...grpc.CallOption) (*OperLogIndexResp, error)
	LoginLogCreate(ctx context.Context, in *LoginLogCreateReq, opts ...grpc.CallOption) (*Response, error)
	OperLogCreate(ctx context.Context, in *OperLogCreateReq, opts ...grpc.CallOption) (*Response, error)
}

type logClient struct {
	cc grpc.ClientConnInterface
}

func NewLogClient(cc grpc.ClientConnInterface) LogClient {
	return &logClient{cc}
}

func (c *logClient) LoginLogIndex(ctx context.Context, in *LoginLogIndexReq, opts ...grpc.CallOption) (*LoginLogIndexResp, error) {
	out := new(LoginLogIndexResp)
	err := c.cc.Invoke(ctx, "/sys.Log/loginLogIndex", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *logClient) OperLogIndex(ctx context.Context, in *OperLogIndexReq, opts ...grpc.CallOption) (*OperLogIndexResp, error) {
	out := new(OperLogIndexResp)
	err := c.cc.Invoke(ctx, "/sys.Log/operLogIndex", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *logClient) LoginLogCreate(ctx context.Context, in *LoginLogCreateReq, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/sys.Log/loginLogCreate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *logClient) OperLogCreate(ctx context.Context, in *OperLogCreateReq, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/sys.Log/operLogCreate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LogServer is the server API for Log service.
// All implementations must embed UnimplementedLogServer
// for forward compatibility
type LogServer interface {
	LoginLogIndex(context.Context, *LoginLogIndexReq) (*LoginLogIndexResp, error)
	OperLogIndex(context.Context, *OperLogIndexReq) (*OperLogIndexResp, error)
	LoginLogCreate(context.Context, *LoginLogCreateReq) (*Response, error)
	OperLogCreate(context.Context, *OperLogCreateReq) (*Response, error)
	mustEmbedUnimplementedLogServer()
}

// UnimplementedLogServer must be embedded to have forward compatible implementations.
type UnimplementedLogServer struct {
}

func (UnimplementedLogServer) LoginLogIndex(context.Context, *LoginLogIndexReq) (*LoginLogIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LoginLogIndex not implemented")
}
func (UnimplementedLogServer) OperLogIndex(context.Context, *OperLogIndexReq) (*OperLogIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OperLogIndex not implemented")
}
func (UnimplementedLogServer) LoginLogCreate(context.Context, *LoginLogCreateReq) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LoginLogCreate not implemented")
}
func (UnimplementedLogServer) OperLogCreate(context.Context, *OperLogCreateReq) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OperLogCreate not implemented")
}
func (UnimplementedLogServer) mustEmbedUnimplementedLogServer() {}

// UnsafeLogServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LogServer will
// result in compilation errors.
type UnsafeLogServer interface {
	mustEmbedUnimplementedLogServer()
}

func RegisterLogServer(s grpc.ServiceRegistrar, srv LogServer) {
	s.RegisterService(&Log_ServiceDesc, srv)
}

func _Log_LoginLogIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoginLogIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LogServer).LoginLogIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sys.Log/loginLogIndex",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LogServer).LoginLogIndex(ctx, req.(*LoginLogIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Log_OperLogIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OperLogIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LogServer).OperLogIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sys.Log/operLogIndex",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LogServer).OperLogIndex(ctx, req.(*OperLogIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Log_LoginLogCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoginLogCreateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LogServer).LoginLogCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sys.Log/loginLogCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LogServer).LoginLogCreate(ctx, req.(*LoginLogCreateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Log_OperLogCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OperLogCreateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LogServer).OperLogCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sys.Log/operLogCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LogServer).OperLogCreate(ctx, req.(*OperLogCreateReq))
	}
	return interceptor(ctx, in, info, handler)
}

// Log_ServiceDesc is the grpc.ServiceDesc for Log service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Log_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sys.Log",
	HandlerType: (*LogServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "loginLogIndex",
			Handler:    _Log_LoginLogIndex_Handler,
		},
		{
			MethodName: "operLogIndex",
			Handler:    _Log_OperLogIndex_Handler,
		},
		{
			MethodName: "loginLogCreate",
			Handler:    _Log_LoginLogCreate_Handler,
		},
		{
			MethodName: "operLogCreate",
			Handler:    _Log_OperLogCreate_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/sys.proto",
}

// ApiClient is the client API for Api service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ApiClient interface {
	ApiCreate(ctx context.Context, in *ApiCreateReq, opts ...grpc.CallOption) (*Response, error)
	ApiIndex(ctx context.Context, in *ApiIndexReq, opts ...grpc.CallOption) (*ApiIndexResp, error)
	ApiUpdate(ctx context.Context, in *ApiUpdateReq, opts ...grpc.CallOption) (*Response, error)
	ApiDelete(ctx context.Context, in *ApiDeleteReq, opts ...grpc.CallOption) (*Response, error)
}

type apiClient struct {
	cc grpc.ClientConnInterface
}

func NewApiClient(cc grpc.ClientConnInterface) ApiClient {
	return &apiClient{cc}
}

func (c *apiClient) ApiCreate(ctx context.Context, in *ApiCreateReq, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/sys.Api/apiCreate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiClient) ApiIndex(ctx context.Context, in *ApiIndexReq, opts ...grpc.CallOption) (*ApiIndexResp, error) {
	out := new(ApiIndexResp)
	err := c.cc.Invoke(ctx, "/sys.Api/apiIndex", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiClient) ApiUpdate(ctx context.Context, in *ApiUpdateReq, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/sys.Api/apiUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiClient) ApiDelete(ctx context.Context, in *ApiDeleteReq, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/sys.Api/apiDelete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ApiServer is the server API for Api service.
// All implementations must embed UnimplementedApiServer
// for forward compatibility
type ApiServer interface {
	ApiCreate(context.Context, *ApiCreateReq) (*Response, error)
	ApiIndex(context.Context, *ApiIndexReq) (*ApiIndexResp, error)
	ApiUpdate(context.Context, *ApiUpdateReq) (*Response, error)
	ApiDelete(context.Context, *ApiDeleteReq) (*Response, error)
	mustEmbedUnimplementedApiServer()
}

// UnimplementedApiServer must be embedded to have forward compatible implementations.
type UnimplementedApiServer struct {
}

func (UnimplementedApiServer) ApiCreate(context.Context, *ApiCreateReq) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ApiCreate not implemented")
}
func (UnimplementedApiServer) ApiIndex(context.Context, *ApiIndexReq) (*ApiIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ApiIndex not implemented")
}
func (UnimplementedApiServer) ApiUpdate(context.Context, *ApiUpdateReq) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ApiUpdate not implemented")
}
func (UnimplementedApiServer) ApiDelete(context.Context, *ApiDeleteReq) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ApiDelete not implemented")
}
func (UnimplementedApiServer) mustEmbedUnimplementedApiServer() {}

// UnsafeApiServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ApiServer will
// result in compilation errors.
type UnsafeApiServer interface {
	mustEmbedUnimplementedApiServer()
}

func RegisterApiServer(s grpc.ServiceRegistrar, srv ApiServer) {
	s.RegisterService(&Api_ServiceDesc, srv)
}

func _Api_ApiCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApiCreateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiServer).ApiCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sys.Api/apiCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiServer).ApiCreate(ctx, req.(*ApiCreateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Api_ApiIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApiIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiServer).ApiIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sys.Api/apiIndex",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiServer).ApiIndex(ctx, req.(*ApiIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Api_ApiUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApiUpdateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiServer).ApiUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sys.Api/apiUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiServer).ApiUpdate(ctx, req.(*ApiUpdateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Api_ApiDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApiDeleteReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiServer).ApiDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sys.Api/apiDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiServer).ApiDelete(ctx, req.(*ApiDeleteReq))
	}
	return interceptor(ctx, in, info, handler)
}

// Api_ServiceDesc is the grpc.ServiceDesc for Api service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Api_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sys.Api",
	HandlerType: (*ApiServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "apiCreate",
			Handler:    _Api_ApiCreate_Handler,
		},
		{
			MethodName: "apiIndex",
			Handler:    _Api_ApiIndex_Handler,
		},
		{
			MethodName: "apiUpdate",
			Handler:    _Api_ApiUpdate_Handler,
		},
		{
			MethodName: "apiDelete",
			Handler:    _Api_ApiDelete_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/sys.proto",
}

// ProjectManageClient is the client API for ProjectManage service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ProjectManageClient interface {
	//
	ProjectInfoCreate(ctx context.Context, in *ProjectInfo, opts ...grpc.CallOption) (*Response, error)
	//
	ProjectInfoUpdate(ctx context.Context, in *ProjectInfo, opts ...grpc.CallOption) (*Response, error)
	//
	ProjectInfoDelete(ctx context.Context, in *ProjectInfoDeleteReq, opts ...grpc.CallOption) (*Response, error)
	//
	ProjectInfoRead(ctx context.Context, in *ProjectInfoReadReq, opts ...grpc.CallOption) (*ProjectInfo, error)
	//
	ProjectInfoIndex(ctx context.Context, in *ProjectInfoIndexReq, opts ...grpc.CallOption) (*ProjectInfoIndexResp, error)
}

type projectManageClient struct {
	cc grpc.ClientConnInterface
}

func NewProjectManageClient(cc grpc.ClientConnInterface) ProjectManageClient {
	return &projectManageClient{cc}
}

func (c *projectManageClient) ProjectInfoCreate(ctx context.Context, in *ProjectInfo, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/sys.ProjectManage/projectInfoCreate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectManageClient) ProjectInfoUpdate(ctx context.Context, in *ProjectInfo, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/sys.ProjectManage/projectInfoUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectManageClient) ProjectInfoDelete(ctx context.Context, in *ProjectInfoDeleteReq, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/sys.ProjectManage/projectInfoDelete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectManageClient) ProjectInfoRead(ctx context.Context, in *ProjectInfoReadReq, opts ...grpc.CallOption) (*ProjectInfo, error) {
	out := new(ProjectInfo)
	err := c.cc.Invoke(ctx, "/sys.ProjectManage/projectInfoRead", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectManageClient) ProjectInfoIndex(ctx context.Context, in *ProjectInfoIndexReq, opts ...grpc.CallOption) (*ProjectInfoIndexResp, error) {
	out := new(ProjectInfoIndexResp)
	err := c.cc.Invoke(ctx, "/sys.ProjectManage/projectInfoIndex", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ProjectManageServer is the server API for ProjectManage service.
// All implementations must embed UnimplementedProjectManageServer
// for forward compatibility
type ProjectManageServer interface {
	//
	ProjectInfoCreate(context.Context, *ProjectInfo) (*Response, error)
	//
	ProjectInfoUpdate(context.Context, *ProjectInfo) (*Response, error)
	//
	ProjectInfoDelete(context.Context, *ProjectInfoDeleteReq) (*Response, error)
	//
	ProjectInfoRead(context.Context, *ProjectInfoReadReq) (*ProjectInfo, error)
	//
	ProjectInfoIndex(context.Context, *ProjectInfoIndexReq) (*ProjectInfoIndexResp, error)
	mustEmbedUnimplementedProjectManageServer()
}

// UnimplementedProjectManageServer must be embedded to have forward compatible implementations.
type UnimplementedProjectManageServer struct {
}

func (UnimplementedProjectManageServer) ProjectInfoCreate(context.Context, *ProjectInfo) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProjectInfoCreate not implemented")
}
func (UnimplementedProjectManageServer) ProjectInfoUpdate(context.Context, *ProjectInfo) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProjectInfoUpdate not implemented")
}
func (UnimplementedProjectManageServer) ProjectInfoDelete(context.Context, *ProjectInfoDeleteReq) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProjectInfoDelete not implemented")
}
func (UnimplementedProjectManageServer) ProjectInfoRead(context.Context, *ProjectInfoReadReq) (*ProjectInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProjectInfoRead not implemented")
}
func (UnimplementedProjectManageServer) ProjectInfoIndex(context.Context, *ProjectInfoIndexReq) (*ProjectInfoIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProjectInfoIndex not implemented")
}
func (UnimplementedProjectManageServer) mustEmbedUnimplementedProjectManageServer() {}

// UnsafeProjectManageServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ProjectManageServer will
// result in compilation errors.
type UnsafeProjectManageServer interface {
	mustEmbedUnimplementedProjectManageServer()
}

func RegisterProjectManageServer(s grpc.ServiceRegistrar, srv ProjectManageServer) {
	s.RegisterService(&ProjectManage_ServiceDesc, srv)
}

func _ProjectManage_ProjectInfoCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProjectInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectManageServer).ProjectInfoCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sys.ProjectManage/projectInfoCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectManageServer).ProjectInfoCreate(ctx, req.(*ProjectInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProjectManage_ProjectInfoUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProjectInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectManageServer).ProjectInfoUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sys.ProjectManage/projectInfoUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectManageServer).ProjectInfoUpdate(ctx, req.(*ProjectInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProjectManage_ProjectInfoDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProjectInfoDeleteReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectManageServer).ProjectInfoDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sys.ProjectManage/projectInfoDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectManageServer).ProjectInfoDelete(ctx, req.(*ProjectInfoDeleteReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProjectManage_ProjectInfoRead_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProjectInfoReadReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectManageServer).ProjectInfoRead(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sys.ProjectManage/projectInfoRead",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectManageServer).ProjectInfoRead(ctx, req.(*ProjectInfoReadReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProjectManage_ProjectInfoIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProjectInfoIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectManageServer).ProjectInfoIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sys.ProjectManage/projectInfoIndex",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectManageServer).ProjectInfoIndex(ctx, req.(*ProjectInfoIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

// ProjectManage_ServiceDesc is the grpc.ServiceDesc for ProjectManage service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ProjectManage_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sys.ProjectManage",
	HandlerType: (*ProjectManageServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "projectInfoCreate",
			Handler:    _ProjectManage_ProjectInfoCreate_Handler,
		},
		{
			MethodName: "projectInfoUpdate",
			Handler:    _ProjectManage_ProjectInfoUpdate_Handler,
		},
		{
			MethodName: "projectInfoDelete",
			Handler:    _ProjectManage_ProjectInfoDelete_Handler,
		},
		{
			MethodName: "projectInfoRead",
			Handler:    _ProjectManage_ProjectInfoRead_Handler,
		},
		{
			MethodName: "projectInfoIndex",
			Handler:    _ProjectManage_ProjectInfoIndex_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/sys.proto",
}

// AreaManageClient is the client API for AreaManage service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AreaManageClient interface {
	//
	AreaInfoCreate(ctx context.Context, in *AreaInfo, opts ...grpc.CallOption) (*Response, error)
	//
	AreaInfoUpdate(ctx context.Context, in *AreaInfo, opts ...grpc.CallOption) (*Response, error)
	//
	AreaInfoDelete(ctx context.Context, in *AreaInfoDeleteReq, opts ...grpc.CallOption) (*Response, error)
	//
	AreaInfoRead(ctx context.Context, in *AreaInfoReadReq, opts ...grpc.CallOption) (*AreaInfo, error)
	//
	AreaInfoIndex(ctx context.Context, in *AreaInfoIndexReq, opts ...grpc.CallOption) (*AreaInfoIndexResp, error)
	//
	AreaInfoTree(ctx context.Context, in *AreaInfoTreeReq, opts ...grpc.CallOption) (*AreaInfoTreeResp, error)
}

type areaManageClient struct {
	cc grpc.ClientConnInterface
}

func NewAreaManageClient(cc grpc.ClientConnInterface) AreaManageClient {
	return &areaManageClient{cc}
}

func (c *areaManageClient) AreaInfoCreate(ctx context.Context, in *AreaInfo, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/sys.AreaManage/areaInfoCreate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *areaManageClient) AreaInfoUpdate(ctx context.Context, in *AreaInfo, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/sys.AreaManage/areaInfoUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *areaManageClient) AreaInfoDelete(ctx context.Context, in *AreaInfoDeleteReq, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/sys.AreaManage/areaInfoDelete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *areaManageClient) AreaInfoRead(ctx context.Context, in *AreaInfoReadReq, opts ...grpc.CallOption) (*AreaInfo, error) {
	out := new(AreaInfo)
	err := c.cc.Invoke(ctx, "/sys.AreaManage/areaInfoRead", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *areaManageClient) AreaInfoIndex(ctx context.Context, in *AreaInfoIndexReq, opts ...grpc.CallOption) (*AreaInfoIndexResp, error) {
	out := new(AreaInfoIndexResp)
	err := c.cc.Invoke(ctx, "/sys.AreaManage/areaInfoIndex", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *areaManageClient) AreaInfoTree(ctx context.Context, in *AreaInfoTreeReq, opts ...grpc.CallOption) (*AreaInfoTreeResp, error) {
	out := new(AreaInfoTreeResp)
	err := c.cc.Invoke(ctx, "/sys.AreaManage/areaInfoTree", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AreaManageServer is the server API for AreaManage service.
// All implementations must embed UnimplementedAreaManageServer
// for forward compatibility
type AreaManageServer interface {
	//
	AreaInfoCreate(context.Context, *AreaInfo) (*Response, error)
	//
	AreaInfoUpdate(context.Context, *AreaInfo) (*Response, error)
	//
	AreaInfoDelete(context.Context, *AreaInfoDeleteReq) (*Response, error)
	//
	AreaInfoRead(context.Context, *AreaInfoReadReq) (*AreaInfo, error)
	//
	AreaInfoIndex(context.Context, *AreaInfoIndexReq) (*AreaInfoIndexResp, error)
	//
	AreaInfoTree(context.Context, *AreaInfoTreeReq) (*AreaInfoTreeResp, error)
	mustEmbedUnimplementedAreaManageServer()
}

// UnimplementedAreaManageServer must be embedded to have forward compatible implementations.
type UnimplementedAreaManageServer struct {
}

func (UnimplementedAreaManageServer) AreaInfoCreate(context.Context, *AreaInfo) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AreaInfoCreate not implemented")
}
func (UnimplementedAreaManageServer) AreaInfoUpdate(context.Context, *AreaInfo) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AreaInfoUpdate not implemented")
}
func (UnimplementedAreaManageServer) AreaInfoDelete(context.Context, *AreaInfoDeleteReq) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AreaInfoDelete not implemented")
}
func (UnimplementedAreaManageServer) AreaInfoRead(context.Context, *AreaInfoReadReq) (*AreaInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AreaInfoRead not implemented")
}
func (UnimplementedAreaManageServer) AreaInfoIndex(context.Context, *AreaInfoIndexReq) (*AreaInfoIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AreaInfoIndex not implemented")
}
func (UnimplementedAreaManageServer) AreaInfoTree(context.Context, *AreaInfoTreeReq) (*AreaInfoTreeResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AreaInfoTree not implemented")
}
func (UnimplementedAreaManageServer) mustEmbedUnimplementedAreaManageServer() {}

// UnsafeAreaManageServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AreaManageServer will
// result in compilation errors.
type UnsafeAreaManageServer interface {
	mustEmbedUnimplementedAreaManageServer()
}

func RegisterAreaManageServer(s grpc.ServiceRegistrar, srv AreaManageServer) {
	s.RegisterService(&AreaManage_ServiceDesc, srv)
}

func _AreaManage_AreaInfoCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AreaInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AreaManageServer).AreaInfoCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sys.AreaManage/areaInfoCreate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AreaManageServer).AreaInfoCreate(ctx, req.(*AreaInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _AreaManage_AreaInfoUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AreaInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AreaManageServer).AreaInfoUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sys.AreaManage/areaInfoUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AreaManageServer).AreaInfoUpdate(ctx, req.(*AreaInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _AreaManage_AreaInfoDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AreaInfoDeleteReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AreaManageServer).AreaInfoDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sys.AreaManage/areaInfoDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AreaManageServer).AreaInfoDelete(ctx, req.(*AreaInfoDeleteReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _AreaManage_AreaInfoRead_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AreaInfoReadReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AreaManageServer).AreaInfoRead(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sys.AreaManage/areaInfoRead",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AreaManageServer).AreaInfoRead(ctx, req.(*AreaInfoReadReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _AreaManage_AreaInfoIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AreaInfoIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AreaManageServer).AreaInfoIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sys.AreaManage/areaInfoIndex",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AreaManageServer).AreaInfoIndex(ctx, req.(*AreaInfoIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _AreaManage_AreaInfoTree_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AreaInfoTreeReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AreaManageServer).AreaInfoTree(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sys.AreaManage/areaInfoTree",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AreaManageServer).AreaInfoTree(ctx, req.(*AreaInfoTreeReq))
	}
	return interceptor(ctx, in, info, handler)
}

// AreaManage_ServiceDesc is the grpc.ServiceDesc for AreaManage service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AreaManage_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sys.AreaManage",
	HandlerType: (*AreaManageServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "areaInfoCreate",
			Handler:    _AreaManage_AreaInfoCreate_Handler,
		},
		{
			MethodName: "areaInfoUpdate",
			Handler:    _AreaManage_AreaInfoUpdate_Handler,
		},
		{
			MethodName: "areaInfoDelete",
			Handler:    _AreaManage_AreaInfoDelete_Handler,
		},
		{
			MethodName: "areaInfoRead",
			Handler:    _AreaManage_AreaInfoRead_Handler,
		},
		{
			MethodName: "areaInfoIndex",
			Handler:    _AreaManage_AreaInfoIndex_Handler,
		},
		{
			MethodName: "areaInfoTree",
			Handler:    _AreaManage_AreaInfoTree_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/sys.proto",
}
