// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v3.19.4
// source: proto/sys.proto

package sys

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	UserManage_UserInfoCreate_FullMethodName         = "/sys.UserManage/userInfoCreate"
	UserManage_UserInfoIndex_FullMethodName          = "/sys.UserManage/userInfoIndex"
	UserManage_UserInfoUpdate_FullMethodName         = "/sys.UserManage/userInfoUpdate"
	UserManage_UserInfoRead_FullMethodName           = "/sys.UserManage/userInfoRead"
	UserManage_UserInfoDelete_FullMethodName         = "/sys.UserManage/userInfoDelete"
	UserManage_UserLogin_FullMethodName              = "/sys.UserManage/userLogin"
	UserManage_UserForgetPwd_FullMethodName          = "/sys.UserManage/userForgetPwd"
	UserManage_UserCaptcha_FullMethodName            = "/sys.UserManage/userCaptcha"
	UserManage_UserCheckToken_FullMethodName         = "/sys.UserManage/userCheckToken"
	UserManage_UserRegister_FullMethodName           = "/sys.UserManage/userRegister"
	UserManage_UserRoleIndex_FullMethodName          = "/sys.UserManage/userRoleIndex"
	UserManage_UserRoleMultiUpdate_FullMethodName    = "/sys.UserManage/userRoleMultiUpdate"
	UserManage_UserProjectMultiUpdate_FullMethodName = "/sys.UserManage/userProjectMultiUpdate"
	UserManage_UserProjectIndex_FullMethodName       = "/sys.UserManage/userProjectIndex"
	UserManage_UserAreaMultiUpdate_FullMethodName    = "/sys.UserManage/userAreaMultiUpdate"
	UserManage_UserAreaIndex_FullMethodName          = "/sys.UserManage/userAreaIndex"
)

// UserManageClient is the client API for UserManage service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UserManageClient interface {
	UserInfoCreate(ctx context.Context, in *UserInfoCreateReq, opts ...grpc.CallOption) (*UserCreateResp, error)
	UserInfoIndex(ctx context.Context, in *UserInfoIndexReq, opts ...grpc.CallOption) (*UserInfoIndexResp, error)
	UserInfoUpdate(ctx context.Context, in *UserInfo, opts ...grpc.CallOption) (*Response, error)
	UserInfoRead(ctx context.Context, in *UserInfoReadReq, opts ...grpc.CallOption) (*UserInfo, error)
	UserInfoDelete(ctx context.Context, in *UserInfoDeleteReq, opts ...grpc.CallOption) (*Response, error)
	UserLogin(ctx context.Context, in *UserLoginReq, opts ...grpc.CallOption) (*UserLoginResp, error)
	UserForgetPwd(ctx context.Context, in *UserForgetPwdReq, opts ...grpc.CallOption) (*Response, error)
	UserCaptcha(ctx context.Context, in *UserCaptchaReq, opts ...grpc.CallOption) (*UserCaptchaResp, error)
	UserCheckToken(ctx context.Context, in *UserCheckTokenReq, opts ...grpc.CallOption) (*UserCheckTokenResp, error)
	UserRegister(ctx context.Context, in *UserRegisterReq, opts ...grpc.CallOption) (*UserRegisterResp, error)
	UserRoleIndex(ctx context.Context, in *UserRoleIndexReq, opts ...grpc.CallOption) (*UserRoleIndexResp, error)
	UserRoleMultiUpdate(ctx context.Context, in *UserRoleMultiUpdateReq, opts ...grpc.CallOption) (*Response, error)
	UserProjectMultiUpdate(ctx context.Context, in *UserProjectMultiUpdateReq, opts ...grpc.CallOption) (*Response, error)
	UserProjectIndex(ctx context.Context, in *UserProjectIndexReq, opts ...grpc.CallOption) (*UserProjectIndexResp, error)
	UserAreaMultiUpdate(ctx context.Context, in *UserAreaMultiUpdateReq, opts ...grpc.CallOption) (*Response, error)
	UserAreaIndex(ctx context.Context, in *UserAreaIndexReq, opts ...grpc.CallOption) (*UserAreaIndexResp, error)
}

type userManageClient struct {
	cc grpc.ClientConnInterface
}

func NewUserManageClient(cc grpc.ClientConnInterface) UserManageClient {
	return &userManageClient{cc}
}

func (c *userManageClient) UserInfoCreate(ctx context.Context, in *UserInfoCreateReq, opts ...grpc.CallOption) (*UserCreateResp, error) {
	out := new(UserCreateResp)
	err := c.cc.Invoke(ctx, UserManage_UserInfoCreate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userManageClient) UserInfoIndex(ctx context.Context, in *UserInfoIndexReq, opts ...grpc.CallOption) (*UserInfoIndexResp, error) {
	out := new(UserInfoIndexResp)
	err := c.cc.Invoke(ctx, UserManage_UserInfoIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userManageClient) UserInfoUpdate(ctx context.Context, in *UserInfo, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, UserManage_UserInfoUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userManageClient) UserInfoRead(ctx context.Context, in *UserInfoReadReq, opts ...grpc.CallOption) (*UserInfo, error) {
	out := new(UserInfo)
	err := c.cc.Invoke(ctx, UserManage_UserInfoRead_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userManageClient) UserInfoDelete(ctx context.Context, in *UserInfoDeleteReq, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, UserManage_UserInfoDelete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userManageClient) UserLogin(ctx context.Context, in *UserLoginReq, opts ...grpc.CallOption) (*UserLoginResp, error) {
	out := new(UserLoginResp)
	err := c.cc.Invoke(ctx, UserManage_UserLogin_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userManageClient) UserForgetPwd(ctx context.Context, in *UserForgetPwdReq, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, UserManage_UserForgetPwd_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userManageClient) UserCaptcha(ctx context.Context, in *UserCaptchaReq, opts ...grpc.CallOption) (*UserCaptchaResp, error) {
	out := new(UserCaptchaResp)
	err := c.cc.Invoke(ctx, UserManage_UserCaptcha_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userManageClient) UserCheckToken(ctx context.Context, in *UserCheckTokenReq, opts ...grpc.CallOption) (*UserCheckTokenResp, error) {
	out := new(UserCheckTokenResp)
	err := c.cc.Invoke(ctx, UserManage_UserCheckToken_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userManageClient) UserRegister(ctx context.Context, in *UserRegisterReq, opts ...grpc.CallOption) (*UserRegisterResp, error) {
	out := new(UserRegisterResp)
	err := c.cc.Invoke(ctx, UserManage_UserRegister_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userManageClient) UserRoleIndex(ctx context.Context, in *UserRoleIndexReq, opts ...grpc.CallOption) (*UserRoleIndexResp, error) {
	out := new(UserRoleIndexResp)
	err := c.cc.Invoke(ctx, UserManage_UserRoleIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userManageClient) UserRoleMultiUpdate(ctx context.Context, in *UserRoleMultiUpdateReq, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, UserManage_UserRoleMultiUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userManageClient) UserProjectMultiUpdate(ctx context.Context, in *UserProjectMultiUpdateReq, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, UserManage_UserProjectMultiUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userManageClient) UserProjectIndex(ctx context.Context, in *UserProjectIndexReq, opts ...grpc.CallOption) (*UserProjectIndexResp, error) {
	out := new(UserProjectIndexResp)
	err := c.cc.Invoke(ctx, UserManage_UserProjectIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userManageClient) UserAreaMultiUpdate(ctx context.Context, in *UserAreaMultiUpdateReq, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, UserManage_UserAreaMultiUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userManageClient) UserAreaIndex(ctx context.Context, in *UserAreaIndexReq, opts ...grpc.CallOption) (*UserAreaIndexResp, error) {
	out := new(UserAreaIndexResp)
	err := c.cc.Invoke(ctx, UserManage_UserAreaIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserManageServer is the server API for UserManage service.
// All implementations must embed UnimplementedUserManageServer
// for forward compatibility
type UserManageServer interface {
	UserInfoCreate(context.Context, *UserInfoCreateReq) (*UserCreateResp, error)
	UserInfoIndex(context.Context, *UserInfoIndexReq) (*UserInfoIndexResp, error)
	UserInfoUpdate(context.Context, *UserInfo) (*Response, error)
	UserInfoRead(context.Context, *UserInfoReadReq) (*UserInfo, error)
	UserInfoDelete(context.Context, *UserInfoDeleteReq) (*Response, error)
	UserLogin(context.Context, *UserLoginReq) (*UserLoginResp, error)
	UserForgetPwd(context.Context, *UserForgetPwdReq) (*Response, error)
	UserCaptcha(context.Context, *UserCaptchaReq) (*UserCaptchaResp, error)
	UserCheckToken(context.Context, *UserCheckTokenReq) (*UserCheckTokenResp, error)
	UserRegister(context.Context, *UserRegisterReq) (*UserRegisterResp, error)
	UserRoleIndex(context.Context, *UserRoleIndexReq) (*UserRoleIndexResp, error)
	UserRoleMultiUpdate(context.Context, *UserRoleMultiUpdateReq) (*Response, error)
	UserProjectMultiUpdate(context.Context, *UserProjectMultiUpdateReq) (*Response, error)
	UserProjectIndex(context.Context, *UserProjectIndexReq) (*UserProjectIndexResp, error)
	UserAreaMultiUpdate(context.Context, *UserAreaMultiUpdateReq) (*Response, error)
	UserAreaIndex(context.Context, *UserAreaIndexReq) (*UserAreaIndexResp, error)
	mustEmbedUnimplementedUserManageServer()
}

// UnimplementedUserManageServer must be embedded to have forward compatible implementations.
type UnimplementedUserManageServer struct {
}

func (UnimplementedUserManageServer) UserInfoCreate(context.Context, *UserInfoCreateReq) (*UserCreateResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserInfoCreate not implemented")
}
func (UnimplementedUserManageServer) UserInfoIndex(context.Context, *UserInfoIndexReq) (*UserInfoIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserInfoIndex not implemented")
}
func (UnimplementedUserManageServer) UserInfoUpdate(context.Context, *UserInfo) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserInfoUpdate not implemented")
}
func (UnimplementedUserManageServer) UserInfoRead(context.Context, *UserInfoReadReq) (*UserInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserInfoRead not implemented")
}
func (UnimplementedUserManageServer) UserInfoDelete(context.Context, *UserInfoDeleteReq) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserInfoDelete not implemented")
}
func (UnimplementedUserManageServer) UserLogin(context.Context, *UserLoginReq) (*UserLoginResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserLogin not implemented")
}
func (UnimplementedUserManageServer) UserForgetPwd(context.Context, *UserForgetPwdReq) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserForgetPwd not implemented")
}
func (UnimplementedUserManageServer) UserCaptcha(context.Context, *UserCaptchaReq) (*UserCaptchaResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserCaptcha not implemented")
}
func (UnimplementedUserManageServer) UserCheckToken(context.Context, *UserCheckTokenReq) (*UserCheckTokenResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserCheckToken not implemented")
}
func (UnimplementedUserManageServer) UserRegister(context.Context, *UserRegisterReq) (*UserRegisterResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserRegister not implemented")
}
func (UnimplementedUserManageServer) UserRoleIndex(context.Context, *UserRoleIndexReq) (*UserRoleIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserRoleIndex not implemented")
}
func (UnimplementedUserManageServer) UserRoleMultiUpdate(context.Context, *UserRoleMultiUpdateReq) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserRoleMultiUpdate not implemented")
}
func (UnimplementedUserManageServer) UserProjectMultiUpdate(context.Context, *UserProjectMultiUpdateReq) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserProjectMultiUpdate not implemented")
}
func (UnimplementedUserManageServer) UserProjectIndex(context.Context, *UserProjectIndexReq) (*UserProjectIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserProjectIndex not implemented")
}
func (UnimplementedUserManageServer) UserAreaMultiUpdate(context.Context, *UserAreaMultiUpdateReq) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserAreaMultiUpdate not implemented")
}
func (UnimplementedUserManageServer) UserAreaIndex(context.Context, *UserAreaIndexReq) (*UserAreaIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserAreaIndex not implemented")
}
func (UnimplementedUserManageServer) mustEmbedUnimplementedUserManageServer() {}

// UnsafeUserManageServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserManageServer will
// result in compilation errors.
type UnsafeUserManageServer interface {
	mustEmbedUnimplementedUserManageServer()
}

func RegisterUserManageServer(s grpc.ServiceRegistrar, srv UserManageServer) {
	s.RegisterService(&UserManage_ServiceDesc, srv)
}

func _UserManage_UserInfoCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserInfoCreateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserManageServer).UserInfoCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserManage_UserInfoCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserManageServer).UserInfoCreate(ctx, req.(*UserInfoCreateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserManage_UserInfoIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserInfoIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserManageServer).UserInfoIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserManage_UserInfoIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserManageServer).UserInfoIndex(ctx, req.(*UserInfoIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserManage_UserInfoUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserManageServer).UserInfoUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserManage_UserInfoUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserManageServer).UserInfoUpdate(ctx, req.(*UserInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserManage_UserInfoRead_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserInfoReadReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserManageServer).UserInfoRead(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserManage_UserInfoRead_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserManageServer).UserInfoRead(ctx, req.(*UserInfoReadReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserManage_UserInfoDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserInfoDeleteReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserManageServer).UserInfoDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserManage_UserInfoDelete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserManageServer).UserInfoDelete(ctx, req.(*UserInfoDeleteReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserManage_UserLogin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserLoginReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserManageServer).UserLogin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserManage_UserLogin_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserManageServer).UserLogin(ctx, req.(*UserLoginReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserManage_UserForgetPwd_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserForgetPwdReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserManageServer).UserForgetPwd(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserManage_UserForgetPwd_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserManageServer).UserForgetPwd(ctx, req.(*UserForgetPwdReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserManage_UserCaptcha_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserCaptchaReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserManageServer).UserCaptcha(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserManage_UserCaptcha_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserManageServer).UserCaptcha(ctx, req.(*UserCaptchaReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserManage_UserCheckToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserCheckTokenReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserManageServer).UserCheckToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserManage_UserCheckToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserManageServer).UserCheckToken(ctx, req.(*UserCheckTokenReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserManage_UserRegister_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserRegisterReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserManageServer).UserRegister(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserManage_UserRegister_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserManageServer).UserRegister(ctx, req.(*UserRegisterReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserManage_UserRoleIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserRoleIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserManageServer).UserRoleIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserManage_UserRoleIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserManageServer).UserRoleIndex(ctx, req.(*UserRoleIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserManage_UserRoleMultiUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserRoleMultiUpdateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserManageServer).UserRoleMultiUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserManage_UserRoleMultiUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserManageServer).UserRoleMultiUpdate(ctx, req.(*UserRoleMultiUpdateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserManage_UserProjectMultiUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserProjectMultiUpdateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserManageServer).UserProjectMultiUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserManage_UserProjectMultiUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserManageServer).UserProjectMultiUpdate(ctx, req.(*UserProjectMultiUpdateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserManage_UserProjectIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserProjectIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserManageServer).UserProjectIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserManage_UserProjectIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserManageServer).UserProjectIndex(ctx, req.(*UserProjectIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserManage_UserAreaMultiUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserAreaMultiUpdateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserManageServer).UserAreaMultiUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserManage_UserAreaMultiUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserManageServer).UserAreaMultiUpdate(ctx, req.(*UserAreaMultiUpdateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserManage_UserAreaIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserAreaIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserManageServer).UserAreaIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserManage_UserAreaIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserManageServer).UserAreaIndex(ctx, req.(*UserAreaIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

// UserManage_ServiceDesc is the grpc.ServiceDesc for UserManage service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserManage_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sys.UserManage",
	HandlerType: (*UserManageServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "userInfoCreate",
			Handler:    _UserManage_UserInfoCreate_Handler,
		},
		{
			MethodName: "userInfoIndex",
			Handler:    _UserManage_UserInfoIndex_Handler,
		},
		{
			MethodName: "userInfoUpdate",
			Handler:    _UserManage_UserInfoUpdate_Handler,
		},
		{
			MethodName: "userInfoRead",
			Handler:    _UserManage_UserInfoRead_Handler,
		},
		{
			MethodName: "userInfoDelete",
			Handler:    _UserManage_UserInfoDelete_Handler,
		},
		{
			MethodName: "userLogin",
			Handler:    _UserManage_UserLogin_Handler,
		},
		{
			MethodName: "userForgetPwd",
			Handler:    _UserManage_UserForgetPwd_Handler,
		},
		{
			MethodName: "userCaptcha",
			Handler:    _UserManage_UserCaptcha_Handler,
		},
		{
			MethodName: "userCheckToken",
			Handler:    _UserManage_UserCheckToken_Handler,
		},
		{
			MethodName: "userRegister",
			Handler:    _UserManage_UserRegister_Handler,
		},
		{
			MethodName: "userRoleIndex",
			Handler:    _UserManage_UserRoleIndex_Handler,
		},
		{
			MethodName: "userRoleMultiUpdate",
			Handler:    _UserManage_UserRoleMultiUpdate_Handler,
		},
		{
			MethodName: "userProjectMultiUpdate",
			Handler:    _UserManage_UserProjectMultiUpdate_Handler,
		},
		{
			MethodName: "userProjectIndex",
			Handler:    _UserManage_UserProjectIndex_Handler,
		},
		{
			MethodName: "userAreaMultiUpdate",
			Handler:    _UserManage_UserAreaMultiUpdate_Handler,
		},
		{
			MethodName: "userAreaIndex",
			Handler:    _UserManage_UserAreaIndex_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/sys.proto",
}

const (
	MenuManage_MenuInfoCreate_FullMethodName = "/sys.MenuManage/menuInfoCreate"
	MenuManage_MenuInfoIndex_FullMethodName  = "/sys.MenuManage/menuInfoIndex"
	MenuManage_MenuInfoUpdate_FullMethodName = "/sys.MenuManage/menuInfoUpdate"
	MenuManage_MenuInfoDelete_FullMethodName = "/sys.MenuManage/menuInfoDelete"
)

// MenuManageClient is the client API for MenuManage service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MenuManageClient interface {
	MenuInfoCreate(ctx context.Context, in *MenuInfo, opts ...grpc.CallOption) (*WithID, error)
	MenuInfoIndex(ctx context.Context, in *MenuInfoIndexReq, opts ...grpc.CallOption) (*MenuInfoIndexResp, error)
	MenuInfoUpdate(ctx context.Context, in *MenuInfo, opts ...grpc.CallOption) (*Response, error)
	MenuInfoDelete(ctx context.Context, in *WithID, opts ...grpc.CallOption) (*Response, error)
}

type menuManageClient struct {
	cc grpc.ClientConnInterface
}

func NewMenuManageClient(cc grpc.ClientConnInterface) MenuManageClient {
	return &menuManageClient{cc}
}

func (c *menuManageClient) MenuInfoCreate(ctx context.Context, in *MenuInfo, opts ...grpc.CallOption) (*WithID, error) {
	out := new(WithID)
	err := c.cc.Invoke(ctx, MenuManage_MenuInfoCreate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *menuManageClient) MenuInfoIndex(ctx context.Context, in *MenuInfoIndexReq, opts ...grpc.CallOption) (*MenuInfoIndexResp, error) {
	out := new(MenuInfoIndexResp)
	err := c.cc.Invoke(ctx, MenuManage_MenuInfoIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *menuManageClient) MenuInfoUpdate(ctx context.Context, in *MenuInfo, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, MenuManage_MenuInfoUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *menuManageClient) MenuInfoDelete(ctx context.Context, in *WithID, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, MenuManage_MenuInfoDelete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MenuManageServer is the server API for MenuManage service.
// All implementations must embed UnimplementedMenuManageServer
// for forward compatibility
type MenuManageServer interface {
	MenuInfoCreate(context.Context, *MenuInfo) (*WithID, error)
	MenuInfoIndex(context.Context, *MenuInfoIndexReq) (*MenuInfoIndexResp, error)
	MenuInfoUpdate(context.Context, *MenuInfo) (*Response, error)
	MenuInfoDelete(context.Context, *WithID) (*Response, error)
	mustEmbedUnimplementedMenuManageServer()
}

// UnimplementedMenuManageServer must be embedded to have forward compatible implementations.
type UnimplementedMenuManageServer struct {
}

func (UnimplementedMenuManageServer) MenuInfoCreate(context.Context, *MenuInfo) (*WithID, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MenuInfoCreate not implemented")
}
func (UnimplementedMenuManageServer) MenuInfoIndex(context.Context, *MenuInfoIndexReq) (*MenuInfoIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MenuInfoIndex not implemented")
}
func (UnimplementedMenuManageServer) MenuInfoUpdate(context.Context, *MenuInfo) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MenuInfoUpdate not implemented")
}
func (UnimplementedMenuManageServer) MenuInfoDelete(context.Context, *WithID) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MenuInfoDelete not implemented")
}
func (UnimplementedMenuManageServer) mustEmbedUnimplementedMenuManageServer() {}

// UnsafeMenuManageServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MenuManageServer will
// result in compilation errors.
type UnsafeMenuManageServer interface {
	mustEmbedUnimplementedMenuManageServer()
}

func RegisterMenuManageServer(s grpc.ServiceRegistrar, srv MenuManageServer) {
	s.RegisterService(&MenuManage_ServiceDesc, srv)
}

func _MenuManage_MenuInfoCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MenuInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MenuManageServer).MenuInfoCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MenuManage_MenuInfoCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MenuManageServer).MenuInfoCreate(ctx, req.(*MenuInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _MenuManage_MenuInfoIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MenuInfoIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MenuManageServer).MenuInfoIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MenuManage_MenuInfoIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MenuManageServer).MenuInfoIndex(ctx, req.(*MenuInfoIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _MenuManage_MenuInfoUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MenuInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MenuManageServer).MenuInfoUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MenuManage_MenuInfoUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MenuManageServer).MenuInfoUpdate(ctx, req.(*MenuInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _MenuManage_MenuInfoDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MenuManageServer).MenuInfoDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MenuManage_MenuInfoDelete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MenuManageServer).MenuInfoDelete(ctx, req.(*WithID))
	}
	return interceptor(ctx, in, info, handler)
}

// MenuManage_ServiceDesc is the grpc.ServiceDesc for MenuManage service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MenuManage_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sys.MenuManage",
	HandlerType: (*MenuManageServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "menuInfoCreate",
			Handler:    _MenuManage_MenuInfoCreate_Handler,
		},
		{
			MethodName: "menuInfoIndex",
			Handler:    _MenuManage_MenuInfoIndex_Handler,
		},
		{
			MethodName: "menuInfoUpdate",
			Handler:    _MenuManage_MenuInfoUpdate_Handler,
		},
		{
			MethodName: "menuInfoDelete",
			Handler:    _MenuManage_MenuInfoDelete_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/sys.proto",
}

const (
	RoleManage_RoleInfoCreate_FullMethodName        = "/sys.RoleManage/roleInfoCreate"
	RoleManage_RoleInfoIndex_FullMethodName         = "/sys.RoleManage/roleInfoIndex"
	RoleManage_RoleInfoUpdate_FullMethodName        = "/sys.RoleManage/roleInfoUpdate"
	RoleManage_RoleInfoDelete_FullMethodName        = "/sys.RoleManage/roleInfoDelete"
	RoleManage_RoleMenuIndex_FullMethodName         = "/sys.RoleManage/roleMenuIndex"
	RoleManage_RoleMenuMultiUpdate_FullMethodName   = "/sys.RoleManage/roleMenuMultiUpdate"
	RoleManage_RoleAppIndex_FullMethodName          = "/sys.RoleManage/roleAppIndex"
	RoleManage_RoleAppMultiUpdate_FullMethodName    = "/sys.RoleManage/roleAppMultiUpdate"
	RoleManage_RoleModuleIndex_FullMethodName       = "/sys.RoleManage/roleModuleIndex"
	RoleManage_RoleModuleMultiUpdate_FullMethodName = "/sys.RoleManage/roleModuleMultiUpdate"
	RoleManage_RoleApiAuth_FullMethodName           = "/sys.RoleManage/roleApiAuth"
	RoleManage_RoleApiMultiUpdate_FullMethodName    = "/sys.RoleManage/roleApiMultiUpdate"
	RoleManage_RoleApiIndex_FullMethodName          = "/sys.RoleManage/roleApiIndex"
)

// RoleManageClient is the client API for RoleManage service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RoleManageClient interface {
	RoleInfoCreate(ctx context.Context, in *RoleInfo, opts ...grpc.CallOption) (*WithID, error)
	RoleInfoIndex(ctx context.Context, in *RoleInfoIndexReq, opts ...grpc.CallOption) (*RoleInfoIndexResp, error)
	RoleInfoUpdate(ctx context.Context, in *RoleInfo, opts ...grpc.CallOption) (*Response, error)
	RoleInfoDelete(ctx context.Context, in *WithID, opts ...grpc.CallOption) (*Response, error)
	RoleMenuIndex(ctx context.Context, in *RoleMenuIndexReq, opts ...grpc.CallOption) (*RoleMenuIndexResp, error)
	RoleMenuMultiUpdate(ctx context.Context, in *RoleMenuMultiUpdateReq, opts ...grpc.CallOption) (*Response, error)
	RoleAppIndex(ctx context.Context, in *RoleAppIndexReq, opts ...grpc.CallOption) (*RoleAppIndexResp, error)
	RoleAppMultiUpdate(ctx context.Context, in *RoleAppMultiUpdateReq, opts ...grpc.CallOption) (*Response, error)
	RoleModuleIndex(ctx context.Context, in *RoleModuleIndexReq, opts ...grpc.CallOption) (*RoleModuleIndexResp, error)
	RoleModuleMultiUpdate(ctx context.Context, in *RoleModuleMultiUpdateReq, opts ...grpc.CallOption) (*Response, error)
	RoleApiAuth(ctx context.Context, in *RoleApiAuthReq, opts ...grpc.CallOption) (*Response, error)
	RoleApiMultiUpdate(ctx context.Context, in *RoleApiMultiUpdateReq, opts ...grpc.CallOption) (*Response, error)
	RoleApiIndex(ctx context.Context, in *RoleApiIndexReq, opts ...grpc.CallOption) (*RoleApiIndexResp, error)
}

type roleManageClient struct {
	cc grpc.ClientConnInterface
}

func NewRoleManageClient(cc grpc.ClientConnInterface) RoleManageClient {
	return &roleManageClient{cc}
}

func (c *roleManageClient) RoleInfoCreate(ctx context.Context, in *RoleInfo, opts ...grpc.CallOption) (*WithID, error) {
	out := new(WithID)
	err := c.cc.Invoke(ctx, RoleManage_RoleInfoCreate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleManageClient) RoleInfoIndex(ctx context.Context, in *RoleInfoIndexReq, opts ...grpc.CallOption) (*RoleInfoIndexResp, error) {
	out := new(RoleInfoIndexResp)
	err := c.cc.Invoke(ctx, RoleManage_RoleInfoIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleManageClient) RoleInfoUpdate(ctx context.Context, in *RoleInfo, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, RoleManage_RoleInfoUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleManageClient) RoleInfoDelete(ctx context.Context, in *WithID, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, RoleManage_RoleInfoDelete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleManageClient) RoleMenuIndex(ctx context.Context, in *RoleMenuIndexReq, opts ...grpc.CallOption) (*RoleMenuIndexResp, error) {
	out := new(RoleMenuIndexResp)
	err := c.cc.Invoke(ctx, RoleManage_RoleMenuIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleManageClient) RoleMenuMultiUpdate(ctx context.Context, in *RoleMenuMultiUpdateReq, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, RoleManage_RoleMenuMultiUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleManageClient) RoleAppIndex(ctx context.Context, in *RoleAppIndexReq, opts ...grpc.CallOption) (*RoleAppIndexResp, error) {
	out := new(RoleAppIndexResp)
	err := c.cc.Invoke(ctx, RoleManage_RoleAppIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleManageClient) RoleAppMultiUpdate(ctx context.Context, in *RoleAppMultiUpdateReq, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, RoleManage_RoleAppMultiUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleManageClient) RoleModuleIndex(ctx context.Context, in *RoleModuleIndexReq, opts ...grpc.CallOption) (*RoleModuleIndexResp, error) {
	out := new(RoleModuleIndexResp)
	err := c.cc.Invoke(ctx, RoleManage_RoleModuleIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleManageClient) RoleModuleMultiUpdate(ctx context.Context, in *RoleModuleMultiUpdateReq, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, RoleManage_RoleModuleMultiUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleManageClient) RoleApiAuth(ctx context.Context, in *RoleApiAuthReq, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, RoleManage_RoleApiAuth_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleManageClient) RoleApiMultiUpdate(ctx context.Context, in *RoleApiMultiUpdateReq, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, RoleManage_RoleApiMultiUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleManageClient) RoleApiIndex(ctx context.Context, in *RoleApiIndexReq, opts ...grpc.CallOption) (*RoleApiIndexResp, error) {
	out := new(RoleApiIndexResp)
	err := c.cc.Invoke(ctx, RoleManage_RoleApiIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RoleManageServer is the server API for RoleManage service.
// All implementations must embed UnimplementedRoleManageServer
// for forward compatibility
type RoleManageServer interface {
	RoleInfoCreate(context.Context, *RoleInfo) (*WithID, error)
	RoleInfoIndex(context.Context, *RoleInfoIndexReq) (*RoleInfoIndexResp, error)
	RoleInfoUpdate(context.Context, *RoleInfo) (*Response, error)
	RoleInfoDelete(context.Context, *WithID) (*Response, error)
	RoleMenuIndex(context.Context, *RoleMenuIndexReq) (*RoleMenuIndexResp, error)
	RoleMenuMultiUpdate(context.Context, *RoleMenuMultiUpdateReq) (*Response, error)
	RoleAppIndex(context.Context, *RoleAppIndexReq) (*RoleAppIndexResp, error)
	RoleAppMultiUpdate(context.Context, *RoleAppMultiUpdateReq) (*Response, error)
	RoleModuleIndex(context.Context, *RoleModuleIndexReq) (*RoleModuleIndexResp, error)
	RoleModuleMultiUpdate(context.Context, *RoleModuleMultiUpdateReq) (*Response, error)
	RoleApiAuth(context.Context, *RoleApiAuthReq) (*Response, error)
	RoleApiMultiUpdate(context.Context, *RoleApiMultiUpdateReq) (*Response, error)
	RoleApiIndex(context.Context, *RoleApiIndexReq) (*RoleApiIndexResp, error)
	mustEmbedUnimplementedRoleManageServer()
}

// UnimplementedRoleManageServer must be embedded to have forward compatible implementations.
type UnimplementedRoleManageServer struct {
}

func (UnimplementedRoleManageServer) RoleInfoCreate(context.Context, *RoleInfo) (*WithID, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RoleInfoCreate not implemented")
}
func (UnimplementedRoleManageServer) RoleInfoIndex(context.Context, *RoleInfoIndexReq) (*RoleInfoIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RoleInfoIndex not implemented")
}
func (UnimplementedRoleManageServer) RoleInfoUpdate(context.Context, *RoleInfo) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RoleInfoUpdate not implemented")
}
func (UnimplementedRoleManageServer) RoleInfoDelete(context.Context, *WithID) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RoleInfoDelete not implemented")
}
func (UnimplementedRoleManageServer) RoleMenuIndex(context.Context, *RoleMenuIndexReq) (*RoleMenuIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RoleMenuIndex not implemented")
}
func (UnimplementedRoleManageServer) RoleMenuMultiUpdate(context.Context, *RoleMenuMultiUpdateReq) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RoleMenuMultiUpdate not implemented")
}
func (UnimplementedRoleManageServer) RoleAppIndex(context.Context, *RoleAppIndexReq) (*RoleAppIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RoleAppIndex not implemented")
}
func (UnimplementedRoleManageServer) RoleAppMultiUpdate(context.Context, *RoleAppMultiUpdateReq) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RoleAppMultiUpdate not implemented")
}
func (UnimplementedRoleManageServer) RoleModuleIndex(context.Context, *RoleModuleIndexReq) (*RoleModuleIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RoleModuleIndex not implemented")
}
func (UnimplementedRoleManageServer) RoleModuleMultiUpdate(context.Context, *RoleModuleMultiUpdateReq) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RoleModuleMultiUpdate not implemented")
}
func (UnimplementedRoleManageServer) RoleApiAuth(context.Context, *RoleApiAuthReq) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RoleApiAuth not implemented")
}
func (UnimplementedRoleManageServer) RoleApiMultiUpdate(context.Context, *RoleApiMultiUpdateReq) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RoleApiMultiUpdate not implemented")
}
func (UnimplementedRoleManageServer) RoleApiIndex(context.Context, *RoleApiIndexReq) (*RoleApiIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RoleApiIndex not implemented")
}
func (UnimplementedRoleManageServer) mustEmbedUnimplementedRoleManageServer() {}

// UnsafeRoleManageServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RoleManageServer will
// result in compilation errors.
type UnsafeRoleManageServer interface {
	mustEmbedUnimplementedRoleManageServer()
}

func RegisterRoleManageServer(s grpc.ServiceRegistrar, srv RoleManageServer) {
	s.RegisterService(&RoleManage_ServiceDesc, srv)
}

func _RoleManage_RoleInfoCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoleInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleManageServer).RoleInfoCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoleManage_RoleInfoCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleManageServer).RoleInfoCreate(ctx, req.(*RoleInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoleManage_RoleInfoIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoleInfoIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleManageServer).RoleInfoIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoleManage_RoleInfoIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleManageServer).RoleInfoIndex(ctx, req.(*RoleInfoIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoleManage_RoleInfoUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoleInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleManageServer).RoleInfoUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoleManage_RoleInfoUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleManageServer).RoleInfoUpdate(ctx, req.(*RoleInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoleManage_RoleInfoDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleManageServer).RoleInfoDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoleManage_RoleInfoDelete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleManageServer).RoleInfoDelete(ctx, req.(*WithID))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoleManage_RoleMenuIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoleMenuIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleManageServer).RoleMenuIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoleManage_RoleMenuIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleManageServer).RoleMenuIndex(ctx, req.(*RoleMenuIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoleManage_RoleMenuMultiUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoleMenuMultiUpdateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleManageServer).RoleMenuMultiUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoleManage_RoleMenuMultiUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleManageServer).RoleMenuMultiUpdate(ctx, req.(*RoleMenuMultiUpdateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoleManage_RoleAppIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoleAppIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleManageServer).RoleAppIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoleManage_RoleAppIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleManageServer).RoleAppIndex(ctx, req.(*RoleAppIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoleManage_RoleAppMultiUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoleAppMultiUpdateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleManageServer).RoleAppMultiUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoleManage_RoleAppMultiUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleManageServer).RoleAppMultiUpdate(ctx, req.(*RoleAppMultiUpdateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoleManage_RoleModuleIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoleModuleIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleManageServer).RoleModuleIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoleManage_RoleModuleIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleManageServer).RoleModuleIndex(ctx, req.(*RoleModuleIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoleManage_RoleModuleMultiUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoleModuleMultiUpdateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleManageServer).RoleModuleMultiUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoleManage_RoleModuleMultiUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleManageServer).RoleModuleMultiUpdate(ctx, req.(*RoleModuleMultiUpdateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoleManage_RoleApiAuth_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoleApiAuthReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleManageServer).RoleApiAuth(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoleManage_RoleApiAuth_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleManageServer).RoleApiAuth(ctx, req.(*RoleApiAuthReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoleManage_RoleApiMultiUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoleApiMultiUpdateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleManageServer).RoleApiMultiUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoleManage_RoleApiMultiUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleManageServer).RoleApiMultiUpdate(ctx, req.(*RoleApiMultiUpdateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoleManage_RoleApiIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoleApiIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleManageServer).RoleApiIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoleManage_RoleApiIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleManageServer).RoleApiIndex(ctx, req.(*RoleApiIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

// RoleManage_ServiceDesc is the grpc.ServiceDesc for RoleManage service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RoleManage_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sys.RoleManage",
	HandlerType: (*RoleManageServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "roleInfoCreate",
			Handler:    _RoleManage_RoleInfoCreate_Handler,
		},
		{
			MethodName: "roleInfoIndex",
			Handler:    _RoleManage_RoleInfoIndex_Handler,
		},
		{
			MethodName: "roleInfoUpdate",
			Handler:    _RoleManage_RoleInfoUpdate_Handler,
		},
		{
			MethodName: "roleInfoDelete",
			Handler:    _RoleManage_RoleInfoDelete_Handler,
		},
		{
			MethodName: "roleMenuIndex",
			Handler:    _RoleManage_RoleMenuIndex_Handler,
		},
		{
			MethodName: "roleMenuMultiUpdate",
			Handler:    _RoleManage_RoleMenuMultiUpdate_Handler,
		},
		{
			MethodName: "roleAppIndex",
			Handler:    _RoleManage_RoleAppIndex_Handler,
		},
		{
			MethodName: "roleAppMultiUpdate",
			Handler:    _RoleManage_RoleAppMultiUpdate_Handler,
		},
		{
			MethodName: "roleModuleIndex",
			Handler:    _RoleManage_RoleModuleIndex_Handler,
		},
		{
			MethodName: "roleModuleMultiUpdate",
			Handler:    _RoleManage_RoleModuleMultiUpdate_Handler,
		},
		{
			MethodName: "roleApiAuth",
			Handler:    _RoleManage_RoleApiAuth_Handler,
		},
		{
			MethodName: "roleApiMultiUpdate",
			Handler:    _RoleManage_RoleApiMultiUpdate_Handler,
		},
		{
			MethodName: "roleApiIndex",
			Handler:    _RoleManage_RoleApiIndex_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/sys.proto",
}

const (
	AppManage_AppInfoCreate_FullMethodName        = "/sys.AppManage/appInfoCreate"
	AppManage_AppInfoIndex_FullMethodName         = "/sys.AppManage/appInfoIndex"
	AppManage_AppInfoUpdate_FullMethodName        = "/sys.AppManage/appInfoUpdate"
	AppManage_AppInfoDelete_FullMethodName        = "/sys.AppManage/appInfoDelete"
	AppManage_AppInfoRead_FullMethodName          = "/sys.AppManage/appInfoRead"
	AppManage_AppModuleIndex_FullMethodName       = "/sys.AppManage/appModuleIndex"
	AppManage_AppModuleMultiUpdate_FullMethodName = "/sys.AppManage/appModuleMultiUpdate"
)

// AppManageClient is the client API for AppManage service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AppManageClient interface {
	AppInfoCreate(ctx context.Context, in *AppInfo, opts ...grpc.CallOption) (*WithID, error)
	AppInfoIndex(ctx context.Context, in *AppInfoIndexReq, opts ...grpc.CallOption) (*AppInfoIndexResp, error)
	AppInfoUpdate(ctx context.Context, in *AppInfo, opts ...grpc.CallOption) (*Response, error)
	AppInfoDelete(ctx context.Context, in *WithIDCode, opts ...grpc.CallOption) (*Response, error)
	AppInfoRead(ctx context.Context, in *WithIDCode, opts ...grpc.CallOption) (*AppInfo, error)
	AppModuleIndex(ctx context.Context, in *AppModuleIndexReq, opts ...grpc.CallOption) (*AppModuleIndexResp, error)
	AppModuleMultiUpdate(ctx context.Context, in *AppModuleMultiUpdateReq, opts ...grpc.CallOption) (*Response, error)
}

type appManageClient struct {
	cc grpc.ClientConnInterface
}

func NewAppManageClient(cc grpc.ClientConnInterface) AppManageClient {
	return &appManageClient{cc}
}

func (c *appManageClient) AppInfoCreate(ctx context.Context, in *AppInfo, opts ...grpc.CallOption) (*WithID, error) {
	out := new(WithID)
	err := c.cc.Invoke(ctx, AppManage_AppInfoCreate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *appManageClient) AppInfoIndex(ctx context.Context, in *AppInfoIndexReq, opts ...grpc.CallOption) (*AppInfoIndexResp, error) {
	out := new(AppInfoIndexResp)
	err := c.cc.Invoke(ctx, AppManage_AppInfoIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *appManageClient) AppInfoUpdate(ctx context.Context, in *AppInfo, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, AppManage_AppInfoUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *appManageClient) AppInfoDelete(ctx context.Context, in *WithIDCode, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, AppManage_AppInfoDelete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *appManageClient) AppInfoRead(ctx context.Context, in *WithIDCode, opts ...grpc.CallOption) (*AppInfo, error) {
	out := new(AppInfo)
	err := c.cc.Invoke(ctx, AppManage_AppInfoRead_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *appManageClient) AppModuleIndex(ctx context.Context, in *AppModuleIndexReq, opts ...grpc.CallOption) (*AppModuleIndexResp, error) {
	out := new(AppModuleIndexResp)
	err := c.cc.Invoke(ctx, AppManage_AppModuleIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *appManageClient) AppModuleMultiUpdate(ctx context.Context, in *AppModuleMultiUpdateReq, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, AppManage_AppModuleMultiUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AppManageServer is the server API for AppManage service.
// All implementations must embed UnimplementedAppManageServer
// for forward compatibility
type AppManageServer interface {
	AppInfoCreate(context.Context, *AppInfo) (*WithID, error)
	AppInfoIndex(context.Context, *AppInfoIndexReq) (*AppInfoIndexResp, error)
	AppInfoUpdate(context.Context, *AppInfo) (*Response, error)
	AppInfoDelete(context.Context, *WithIDCode) (*Response, error)
	AppInfoRead(context.Context, *WithIDCode) (*AppInfo, error)
	AppModuleIndex(context.Context, *AppModuleIndexReq) (*AppModuleIndexResp, error)
	AppModuleMultiUpdate(context.Context, *AppModuleMultiUpdateReq) (*Response, error)
	mustEmbedUnimplementedAppManageServer()
}

// UnimplementedAppManageServer must be embedded to have forward compatible implementations.
type UnimplementedAppManageServer struct {
}

func (UnimplementedAppManageServer) AppInfoCreate(context.Context, *AppInfo) (*WithID, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AppInfoCreate not implemented")
}
func (UnimplementedAppManageServer) AppInfoIndex(context.Context, *AppInfoIndexReq) (*AppInfoIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AppInfoIndex not implemented")
}
func (UnimplementedAppManageServer) AppInfoUpdate(context.Context, *AppInfo) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AppInfoUpdate not implemented")
}
func (UnimplementedAppManageServer) AppInfoDelete(context.Context, *WithIDCode) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AppInfoDelete not implemented")
}
func (UnimplementedAppManageServer) AppInfoRead(context.Context, *WithIDCode) (*AppInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AppInfoRead not implemented")
}
func (UnimplementedAppManageServer) AppModuleIndex(context.Context, *AppModuleIndexReq) (*AppModuleIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AppModuleIndex not implemented")
}
func (UnimplementedAppManageServer) AppModuleMultiUpdate(context.Context, *AppModuleMultiUpdateReq) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AppModuleMultiUpdate not implemented")
}
func (UnimplementedAppManageServer) mustEmbedUnimplementedAppManageServer() {}

// UnsafeAppManageServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AppManageServer will
// result in compilation errors.
type UnsafeAppManageServer interface {
	mustEmbedUnimplementedAppManageServer()
}

func RegisterAppManageServer(s grpc.ServiceRegistrar, srv AppManageServer) {
	s.RegisterService(&AppManage_ServiceDesc, srv)
}

func _AppManage_AppInfoCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AppInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppManageServer).AppInfoCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AppManage_AppInfoCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppManageServer).AppInfoCreate(ctx, req.(*AppInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _AppManage_AppInfoIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AppInfoIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppManageServer).AppInfoIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AppManage_AppInfoIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppManageServer).AppInfoIndex(ctx, req.(*AppInfoIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _AppManage_AppInfoUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AppInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppManageServer).AppInfoUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AppManage_AppInfoUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppManageServer).AppInfoUpdate(ctx, req.(*AppInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _AppManage_AppInfoDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithIDCode)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppManageServer).AppInfoDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AppManage_AppInfoDelete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppManageServer).AppInfoDelete(ctx, req.(*WithIDCode))
	}
	return interceptor(ctx, in, info, handler)
}

func _AppManage_AppInfoRead_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithIDCode)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppManageServer).AppInfoRead(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AppManage_AppInfoRead_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppManageServer).AppInfoRead(ctx, req.(*WithIDCode))
	}
	return interceptor(ctx, in, info, handler)
}

func _AppManage_AppModuleIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AppModuleIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppManageServer).AppModuleIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AppManage_AppModuleIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppManageServer).AppModuleIndex(ctx, req.(*AppModuleIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _AppManage_AppModuleMultiUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AppModuleMultiUpdateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppManageServer).AppModuleMultiUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AppManage_AppModuleMultiUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppManageServer).AppModuleMultiUpdate(ctx, req.(*AppModuleMultiUpdateReq))
	}
	return interceptor(ctx, in, info, handler)
}

// AppManage_ServiceDesc is the grpc.ServiceDesc for AppManage service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AppManage_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sys.AppManage",
	HandlerType: (*AppManageServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "appInfoCreate",
			Handler:    _AppManage_AppInfoCreate_Handler,
		},
		{
			MethodName: "appInfoIndex",
			Handler:    _AppManage_AppInfoIndex_Handler,
		},
		{
			MethodName: "appInfoUpdate",
			Handler:    _AppManage_AppInfoUpdate_Handler,
		},
		{
			MethodName: "appInfoDelete",
			Handler:    _AppManage_AppInfoDelete_Handler,
		},
		{
			MethodName: "appInfoRead",
			Handler:    _AppManage_AppInfoRead_Handler,
		},
		{
			MethodName: "appModuleIndex",
			Handler:    _AppManage_AppModuleIndex_Handler,
		},
		{
			MethodName: "appModuleMultiUpdate",
			Handler:    _AppManage_AppModuleMultiUpdate_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/sys.proto",
}

const (
	ModuleManage_ModuleInfoCreate_FullMethodName = "/sys.ModuleManage/moduleInfoCreate"
	ModuleManage_ModuleInfoIndex_FullMethodName  = "/sys.ModuleManage/moduleInfoIndex"
	ModuleManage_ModuleInfoUpdate_FullMethodName = "/sys.ModuleManage/moduleInfoUpdate"
	ModuleManage_ModuleInfoDelete_FullMethodName = "/sys.ModuleManage/moduleInfoDelete"
	ModuleManage_ModuleInfoRead_FullMethodName   = "/sys.ModuleManage/moduleInfoRead"
	ModuleManage_ModuleMenuCreate_FullMethodName = "/sys.ModuleManage/moduleMenuCreate"
	ModuleManage_ModuleMenuIndex_FullMethodName  = "/sys.ModuleManage/moduleMenuIndex"
	ModuleManage_ModuleMenuUpdate_FullMethodName = "/sys.ModuleManage/moduleMenuUpdate"
	ModuleManage_ModuleMenuDelete_FullMethodName = "/sys.ModuleManage/moduleMenuDelete"
	ModuleManage_ModuleApiCreate_FullMethodName  = "/sys.ModuleManage/moduleApiCreate"
	ModuleManage_ModuleApiIndex_FullMethodName   = "/sys.ModuleManage/moduleApiIndex"
	ModuleManage_ModuleApiUpdate_FullMethodName  = "/sys.ModuleManage/moduleApiUpdate"
	ModuleManage_ModuleApiDelete_FullMethodName  = "/sys.ModuleManage/moduleApiDelete"
)

// ModuleManageClient is the client API for ModuleManage service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ModuleManageClient interface {
	ModuleInfoCreate(ctx context.Context, in *ModuleInfo, opts ...grpc.CallOption) (*WithID, error)
	ModuleInfoIndex(ctx context.Context, in *ModuleInfoIndexReq, opts ...grpc.CallOption) (*ModuleInfoIndexResp, error)
	ModuleInfoUpdate(ctx context.Context, in *ModuleInfo, opts ...grpc.CallOption) (*Response, error)
	ModuleInfoDelete(ctx context.Context, in *WithIDCode, opts ...grpc.CallOption) (*Response, error)
	ModuleInfoRead(ctx context.Context, in *WithIDCode, opts ...grpc.CallOption) (*ModuleInfo, error)
	ModuleMenuCreate(ctx context.Context, in *MenuInfo, opts ...grpc.CallOption) (*WithID, error)
	ModuleMenuIndex(ctx context.Context, in *MenuInfoIndexReq, opts ...grpc.CallOption) (*MenuInfoIndexResp, error)
	ModuleMenuUpdate(ctx context.Context, in *MenuInfo, opts ...grpc.CallOption) (*Response, error)
	ModuleMenuDelete(ctx context.Context, in *WithID, opts ...grpc.CallOption) (*Response, error)
	ModuleApiCreate(ctx context.Context, in *ApiInfo, opts ...grpc.CallOption) (*WithID, error)
	ModuleApiIndex(ctx context.Context, in *ApiInfoIndexReq, opts ...grpc.CallOption) (*ApiInfoIndexResp, error)
	ModuleApiUpdate(ctx context.Context, in *ApiInfo, opts ...grpc.CallOption) (*Response, error)
	ModuleApiDelete(ctx context.Context, in *WithID, opts ...grpc.CallOption) (*Response, error)
}

type moduleManageClient struct {
	cc grpc.ClientConnInterface
}

func NewModuleManageClient(cc grpc.ClientConnInterface) ModuleManageClient {
	return &moduleManageClient{cc}
}

func (c *moduleManageClient) ModuleInfoCreate(ctx context.Context, in *ModuleInfo, opts ...grpc.CallOption) (*WithID, error) {
	out := new(WithID)
	err := c.cc.Invoke(ctx, ModuleManage_ModuleInfoCreate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *moduleManageClient) ModuleInfoIndex(ctx context.Context, in *ModuleInfoIndexReq, opts ...grpc.CallOption) (*ModuleInfoIndexResp, error) {
	out := new(ModuleInfoIndexResp)
	err := c.cc.Invoke(ctx, ModuleManage_ModuleInfoIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *moduleManageClient) ModuleInfoUpdate(ctx context.Context, in *ModuleInfo, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, ModuleManage_ModuleInfoUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *moduleManageClient) ModuleInfoDelete(ctx context.Context, in *WithIDCode, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, ModuleManage_ModuleInfoDelete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *moduleManageClient) ModuleInfoRead(ctx context.Context, in *WithIDCode, opts ...grpc.CallOption) (*ModuleInfo, error) {
	out := new(ModuleInfo)
	err := c.cc.Invoke(ctx, ModuleManage_ModuleInfoRead_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *moduleManageClient) ModuleMenuCreate(ctx context.Context, in *MenuInfo, opts ...grpc.CallOption) (*WithID, error) {
	out := new(WithID)
	err := c.cc.Invoke(ctx, ModuleManage_ModuleMenuCreate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *moduleManageClient) ModuleMenuIndex(ctx context.Context, in *MenuInfoIndexReq, opts ...grpc.CallOption) (*MenuInfoIndexResp, error) {
	out := new(MenuInfoIndexResp)
	err := c.cc.Invoke(ctx, ModuleManage_ModuleMenuIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *moduleManageClient) ModuleMenuUpdate(ctx context.Context, in *MenuInfo, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, ModuleManage_ModuleMenuUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *moduleManageClient) ModuleMenuDelete(ctx context.Context, in *WithID, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, ModuleManage_ModuleMenuDelete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *moduleManageClient) ModuleApiCreate(ctx context.Context, in *ApiInfo, opts ...grpc.CallOption) (*WithID, error) {
	out := new(WithID)
	err := c.cc.Invoke(ctx, ModuleManage_ModuleApiCreate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *moduleManageClient) ModuleApiIndex(ctx context.Context, in *ApiInfoIndexReq, opts ...grpc.CallOption) (*ApiInfoIndexResp, error) {
	out := new(ApiInfoIndexResp)
	err := c.cc.Invoke(ctx, ModuleManage_ModuleApiIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *moduleManageClient) ModuleApiUpdate(ctx context.Context, in *ApiInfo, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, ModuleManage_ModuleApiUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *moduleManageClient) ModuleApiDelete(ctx context.Context, in *WithID, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, ModuleManage_ModuleApiDelete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ModuleManageServer is the server API for ModuleManage service.
// All implementations must embed UnimplementedModuleManageServer
// for forward compatibility
type ModuleManageServer interface {
	ModuleInfoCreate(context.Context, *ModuleInfo) (*WithID, error)
	ModuleInfoIndex(context.Context, *ModuleInfoIndexReq) (*ModuleInfoIndexResp, error)
	ModuleInfoUpdate(context.Context, *ModuleInfo) (*Response, error)
	ModuleInfoDelete(context.Context, *WithIDCode) (*Response, error)
	ModuleInfoRead(context.Context, *WithIDCode) (*ModuleInfo, error)
	ModuleMenuCreate(context.Context, *MenuInfo) (*WithID, error)
	ModuleMenuIndex(context.Context, *MenuInfoIndexReq) (*MenuInfoIndexResp, error)
	ModuleMenuUpdate(context.Context, *MenuInfo) (*Response, error)
	ModuleMenuDelete(context.Context, *WithID) (*Response, error)
	ModuleApiCreate(context.Context, *ApiInfo) (*WithID, error)
	ModuleApiIndex(context.Context, *ApiInfoIndexReq) (*ApiInfoIndexResp, error)
	ModuleApiUpdate(context.Context, *ApiInfo) (*Response, error)
	ModuleApiDelete(context.Context, *WithID) (*Response, error)
	mustEmbedUnimplementedModuleManageServer()
}

// UnimplementedModuleManageServer must be embedded to have forward compatible implementations.
type UnimplementedModuleManageServer struct {
}

func (UnimplementedModuleManageServer) ModuleInfoCreate(context.Context, *ModuleInfo) (*WithID, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ModuleInfoCreate not implemented")
}
func (UnimplementedModuleManageServer) ModuleInfoIndex(context.Context, *ModuleInfoIndexReq) (*ModuleInfoIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ModuleInfoIndex not implemented")
}
func (UnimplementedModuleManageServer) ModuleInfoUpdate(context.Context, *ModuleInfo) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ModuleInfoUpdate not implemented")
}
func (UnimplementedModuleManageServer) ModuleInfoDelete(context.Context, *WithIDCode) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ModuleInfoDelete not implemented")
}
func (UnimplementedModuleManageServer) ModuleInfoRead(context.Context, *WithIDCode) (*ModuleInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ModuleInfoRead not implemented")
}
func (UnimplementedModuleManageServer) ModuleMenuCreate(context.Context, *MenuInfo) (*WithID, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ModuleMenuCreate not implemented")
}
func (UnimplementedModuleManageServer) ModuleMenuIndex(context.Context, *MenuInfoIndexReq) (*MenuInfoIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ModuleMenuIndex not implemented")
}
func (UnimplementedModuleManageServer) ModuleMenuUpdate(context.Context, *MenuInfo) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ModuleMenuUpdate not implemented")
}
func (UnimplementedModuleManageServer) ModuleMenuDelete(context.Context, *WithID) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ModuleMenuDelete not implemented")
}
func (UnimplementedModuleManageServer) ModuleApiCreate(context.Context, *ApiInfo) (*WithID, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ModuleApiCreate not implemented")
}
func (UnimplementedModuleManageServer) ModuleApiIndex(context.Context, *ApiInfoIndexReq) (*ApiInfoIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ModuleApiIndex not implemented")
}
func (UnimplementedModuleManageServer) ModuleApiUpdate(context.Context, *ApiInfo) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ModuleApiUpdate not implemented")
}
func (UnimplementedModuleManageServer) ModuleApiDelete(context.Context, *WithID) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ModuleApiDelete not implemented")
}
func (UnimplementedModuleManageServer) mustEmbedUnimplementedModuleManageServer() {}

// UnsafeModuleManageServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ModuleManageServer will
// result in compilation errors.
type UnsafeModuleManageServer interface {
	mustEmbedUnimplementedModuleManageServer()
}

func RegisterModuleManageServer(s grpc.ServiceRegistrar, srv ModuleManageServer) {
	s.RegisterService(&ModuleManage_ServiceDesc, srv)
}

func _ModuleManage_ModuleInfoCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ModuleInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModuleManageServer).ModuleInfoCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ModuleManage_ModuleInfoCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModuleManageServer).ModuleInfoCreate(ctx, req.(*ModuleInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _ModuleManage_ModuleInfoIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ModuleInfoIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModuleManageServer).ModuleInfoIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ModuleManage_ModuleInfoIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModuleManageServer).ModuleInfoIndex(ctx, req.(*ModuleInfoIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ModuleManage_ModuleInfoUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ModuleInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModuleManageServer).ModuleInfoUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ModuleManage_ModuleInfoUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModuleManageServer).ModuleInfoUpdate(ctx, req.(*ModuleInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _ModuleManage_ModuleInfoDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithIDCode)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModuleManageServer).ModuleInfoDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ModuleManage_ModuleInfoDelete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModuleManageServer).ModuleInfoDelete(ctx, req.(*WithIDCode))
	}
	return interceptor(ctx, in, info, handler)
}

func _ModuleManage_ModuleInfoRead_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithIDCode)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModuleManageServer).ModuleInfoRead(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ModuleManage_ModuleInfoRead_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModuleManageServer).ModuleInfoRead(ctx, req.(*WithIDCode))
	}
	return interceptor(ctx, in, info, handler)
}

func _ModuleManage_ModuleMenuCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MenuInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModuleManageServer).ModuleMenuCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ModuleManage_ModuleMenuCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModuleManageServer).ModuleMenuCreate(ctx, req.(*MenuInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _ModuleManage_ModuleMenuIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MenuInfoIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModuleManageServer).ModuleMenuIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ModuleManage_ModuleMenuIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModuleManageServer).ModuleMenuIndex(ctx, req.(*MenuInfoIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ModuleManage_ModuleMenuUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MenuInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModuleManageServer).ModuleMenuUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ModuleManage_ModuleMenuUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModuleManageServer).ModuleMenuUpdate(ctx, req.(*MenuInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _ModuleManage_ModuleMenuDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModuleManageServer).ModuleMenuDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ModuleManage_ModuleMenuDelete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModuleManageServer).ModuleMenuDelete(ctx, req.(*WithID))
	}
	return interceptor(ctx, in, info, handler)
}

func _ModuleManage_ModuleApiCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApiInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModuleManageServer).ModuleApiCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ModuleManage_ModuleApiCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModuleManageServer).ModuleApiCreate(ctx, req.(*ApiInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _ModuleManage_ModuleApiIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApiInfoIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModuleManageServer).ModuleApiIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ModuleManage_ModuleApiIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModuleManageServer).ModuleApiIndex(ctx, req.(*ApiInfoIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ModuleManage_ModuleApiUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApiInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModuleManageServer).ModuleApiUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ModuleManage_ModuleApiUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModuleManageServer).ModuleApiUpdate(ctx, req.(*ApiInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _ModuleManage_ModuleApiDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ModuleManageServer).ModuleApiDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ModuleManage_ModuleApiDelete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ModuleManageServer).ModuleApiDelete(ctx, req.(*WithID))
	}
	return interceptor(ctx, in, info, handler)
}

// ModuleManage_ServiceDesc is the grpc.ServiceDesc for ModuleManage service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ModuleManage_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sys.ModuleManage",
	HandlerType: (*ModuleManageServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "moduleInfoCreate",
			Handler:    _ModuleManage_ModuleInfoCreate_Handler,
		},
		{
			MethodName: "moduleInfoIndex",
			Handler:    _ModuleManage_ModuleInfoIndex_Handler,
		},
		{
			MethodName: "moduleInfoUpdate",
			Handler:    _ModuleManage_ModuleInfoUpdate_Handler,
		},
		{
			MethodName: "moduleInfoDelete",
			Handler:    _ModuleManage_ModuleInfoDelete_Handler,
		},
		{
			MethodName: "moduleInfoRead",
			Handler:    _ModuleManage_ModuleInfoRead_Handler,
		},
		{
			MethodName: "moduleMenuCreate",
			Handler:    _ModuleManage_ModuleMenuCreate_Handler,
		},
		{
			MethodName: "moduleMenuIndex",
			Handler:    _ModuleManage_ModuleMenuIndex_Handler,
		},
		{
			MethodName: "moduleMenuUpdate",
			Handler:    _ModuleManage_ModuleMenuUpdate_Handler,
		},
		{
			MethodName: "moduleMenuDelete",
			Handler:    _ModuleManage_ModuleMenuDelete_Handler,
		},
		{
			MethodName: "moduleApiCreate",
			Handler:    _ModuleManage_ModuleApiCreate_Handler,
		},
		{
			MethodName: "moduleApiIndex",
			Handler:    _ModuleManage_ModuleApiIndex_Handler,
		},
		{
			MethodName: "moduleApiUpdate",
			Handler:    _ModuleManage_ModuleApiUpdate_Handler,
		},
		{
			MethodName: "moduleApiDelete",
			Handler:    _ModuleManage_ModuleApiDelete_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/sys.proto",
}

const (
	Common_Config_FullMethodName = "/sys.Common/config"
)

// CommonClient is the client API for Common service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CommonClient interface {
	Config(ctx context.Context, in *Response, opts ...grpc.CallOption) (*ConfigResp, error)
}

type commonClient struct {
	cc grpc.ClientConnInterface
}

func NewCommonClient(cc grpc.ClientConnInterface) CommonClient {
	return &commonClient{cc}
}

func (c *commonClient) Config(ctx context.Context, in *Response, opts ...grpc.CallOption) (*ConfigResp, error) {
	out := new(ConfigResp)
	err := c.cc.Invoke(ctx, Common_Config_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CommonServer is the server API for Common service.
// All implementations must embed UnimplementedCommonServer
// for forward compatibility
type CommonServer interface {
	Config(context.Context, *Response) (*ConfigResp, error)
	mustEmbedUnimplementedCommonServer()
}

// UnimplementedCommonServer must be embedded to have forward compatible implementations.
type UnimplementedCommonServer struct {
}

func (UnimplementedCommonServer) Config(context.Context, *Response) (*ConfigResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Config not implemented")
}
func (UnimplementedCommonServer) mustEmbedUnimplementedCommonServer() {}

// UnsafeCommonServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CommonServer will
// result in compilation errors.
type UnsafeCommonServer interface {
	mustEmbedUnimplementedCommonServer()
}

func RegisterCommonServer(s grpc.ServiceRegistrar, srv CommonServer) {
	s.RegisterService(&Common_ServiceDesc, srv)
}

func _Common_Config_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Response)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommonServer).Config(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Common_Config_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommonServer).Config(ctx, req.(*Response))
	}
	return interceptor(ctx, in, info, handler)
}

// Common_ServiceDesc is the grpc.ServiceDesc for Common service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Common_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sys.Common",
	HandlerType: (*CommonServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "config",
			Handler:    _Common_Config_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/sys.proto",
}

const (
	Log_LoginLogIndex_FullMethodName  = "/sys.Log/loginLogIndex"
	Log_OperLogIndex_FullMethodName   = "/sys.Log/operLogIndex"
	Log_LoginLogCreate_FullMethodName = "/sys.Log/loginLogCreate"
	Log_OperLogCreate_FullMethodName  = "/sys.Log/operLogCreate"
)

// LogClient is the client API for Log service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type LogClient interface {
	LoginLogIndex(ctx context.Context, in *LoginLogIndexReq, opts ...grpc.CallOption) (*LoginLogIndexResp, error)
	OperLogIndex(ctx context.Context, in *OperLogIndexReq, opts ...grpc.CallOption) (*OperLogIndexResp, error)
	LoginLogCreate(ctx context.Context, in *LoginLogCreateReq, opts ...grpc.CallOption) (*Response, error)
	OperLogCreate(ctx context.Context, in *OperLogCreateReq, opts ...grpc.CallOption) (*Response, error)
}

type logClient struct {
	cc grpc.ClientConnInterface
}

func NewLogClient(cc grpc.ClientConnInterface) LogClient {
	return &logClient{cc}
}

func (c *logClient) LoginLogIndex(ctx context.Context, in *LoginLogIndexReq, opts ...grpc.CallOption) (*LoginLogIndexResp, error) {
	out := new(LoginLogIndexResp)
	err := c.cc.Invoke(ctx, Log_LoginLogIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *logClient) OperLogIndex(ctx context.Context, in *OperLogIndexReq, opts ...grpc.CallOption) (*OperLogIndexResp, error) {
	out := new(OperLogIndexResp)
	err := c.cc.Invoke(ctx, Log_OperLogIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *logClient) LoginLogCreate(ctx context.Context, in *LoginLogCreateReq, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, Log_LoginLogCreate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *logClient) OperLogCreate(ctx context.Context, in *OperLogCreateReq, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, Log_OperLogCreate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LogServer is the server API for Log service.
// All implementations must embed UnimplementedLogServer
// for forward compatibility
type LogServer interface {
	LoginLogIndex(context.Context, *LoginLogIndexReq) (*LoginLogIndexResp, error)
	OperLogIndex(context.Context, *OperLogIndexReq) (*OperLogIndexResp, error)
	LoginLogCreate(context.Context, *LoginLogCreateReq) (*Response, error)
	OperLogCreate(context.Context, *OperLogCreateReq) (*Response, error)
	mustEmbedUnimplementedLogServer()
}

// UnimplementedLogServer must be embedded to have forward compatible implementations.
type UnimplementedLogServer struct {
}

func (UnimplementedLogServer) LoginLogIndex(context.Context, *LoginLogIndexReq) (*LoginLogIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LoginLogIndex not implemented")
}
func (UnimplementedLogServer) OperLogIndex(context.Context, *OperLogIndexReq) (*OperLogIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OperLogIndex not implemented")
}
func (UnimplementedLogServer) LoginLogCreate(context.Context, *LoginLogCreateReq) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LoginLogCreate not implemented")
}
func (UnimplementedLogServer) OperLogCreate(context.Context, *OperLogCreateReq) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OperLogCreate not implemented")
}
func (UnimplementedLogServer) mustEmbedUnimplementedLogServer() {}

// UnsafeLogServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LogServer will
// result in compilation errors.
type UnsafeLogServer interface {
	mustEmbedUnimplementedLogServer()
}

func RegisterLogServer(s grpc.ServiceRegistrar, srv LogServer) {
	s.RegisterService(&Log_ServiceDesc, srv)
}

func _Log_LoginLogIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoginLogIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LogServer).LoginLogIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Log_LoginLogIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LogServer).LoginLogIndex(ctx, req.(*LoginLogIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Log_OperLogIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OperLogIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LogServer).OperLogIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Log_OperLogIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LogServer).OperLogIndex(ctx, req.(*OperLogIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Log_LoginLogCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoginLogCreateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LogServer).LoginLogCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Log_LoginLogCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LogServer).LoginLogCreate(ctx, req.(*LoginLogCreateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Log_OperLogCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OperLogCreateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LogServer).OperLogCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Log_OperLogCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LogServer).OperLogCreate(ctx, req.(*OperLogCreateReq))
	}
	return interceptor(ctx, in, info, handler)
}

// Log_ServiceDesc is the grpc.ServiceDesc for Log service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Log_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sys.Log",
	HandlerType: (*LogServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "loginLogIndex",
			Handler:    _Log_LoginLogIndex_Handler,
		},
		{
			MethodName: "operLogIndex",
			Handler:    _Log_OperLogIndex_Handler,
		},
		{
			MethodName: "loginLogCreate",
			Handler:    _Log_LoginLogCreate_Handler,
		},
		{
			MethodName: "operLogCreate",
			Handler:    _Log_OperLogCreate_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/sys.proto",
}

const (
	ApiManage_ApiInfoCreate_FullMethodName = "/sys.ApiManage/apiInfoCreate"
	ApiManage_ApiInfoIndex_FullMethodName  = "/sys.ApiManage/apiInfoIndex"
	ApiManage_ApiInfoUpdate_FullMethodName = "/sys.ApiManage/apiInfoUpdate"
	ApiManage_ApiInfoDelete_FullMethodName = "/sys.ApiManage/apiInfoDelete"
)

// ApiManageClient is the client API for ApiManage service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ApiManageClient interface {
	ApiInfoCreate(ctx context.Context, in *ApiInfo, opts ...grpc.CallOption) (*WithID, error)
	ApiInfoIndex(ctx context.Context, in *ApiInfoIndexReq, opts ...grpc.CallOption) (*ApiInfoIndexResp, error)
	ApiInfoUpdate(ctx context.Context, in *ApiInfo, opts ...grpc.CallOption) (*Response, error)
	ApiInfoDelete(ctx context.Context, in *WithID, opts ...grpc.CallOption) (*Response, error)
}

type apiManageClient struct {
	cc grpc.ClientConnInterface
}

func NewApiManageClient(cc grpc.ClientConnInterface) ApiManageClient {
	return &apiManageClient{cc}
}

func (c *apiManageClient) ApiInfoCreate(ctx context.Context, in *ApiInfo, opts ...grpc.CallOption) (*WithID, error) {
	out := new(WithID)
	err := c.cc.Invoke(ctx, ApiManage_ApiInfoCreate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiManageClient) ApiInfoIndex(ctx context.Context, in *ApiInfoIndexReq, opts ...grpc.CallOption) (*ApiInfoIndexResp, error) {
	out := new(ApiInfoIndexResp)
	err := c.cc.Invoke(ctx, ApiManage_ApiInfoIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiManageClient) ApiInfoUpdate(ctx context.Context, in *ApiInfo, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, ApiManage_ApiInfoUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiManageClient) ApiInfoDelete(ctx context.Context, in *WithID, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, ApiManage_ApiInfoDelete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ApiManageServer is the server API for ApiManage service.
// All implementations must embed UnimplementedApiManageServer
// for forward compatibility
type ApiManageServer interface {
	ApiInfoCreate(context.Context, *ApiInfo) (*WithID, error)
	ApiInfoIndex(context.Context, *ApiInfoIndexReq) (*ApiInfoIndexResp, error)
	ApiInfoUpdate(context.Context, *ApiInfo) (*Response, error)
	ApiInfoDelete(context.Context, *WithID) (*Response, error)
	mustEmbedUnimplementedApiManageServer()
}

// UnimplementedApiManageServer must be embedded to have forward compatible implementations.
type UnimplementedApiManageServer struct {
}

func (UnimplementedApiManageServer) ApiInfoCreate(context.Context, *ApiInfo) (*WithID, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ApiInfoCreate not implemented")
}
func (UnimplementedApiManageServer) ApiInfoIndex(context.Context, *ApiInfoIndexReq) (*ApiInfoIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ApiInfoIndex not implemented")
}
func (UnimplementedApiManageServer) ApiInfoUpdate(context.Context, *ApiInfo) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ApiInfoUpdate not implemented")
}
func (UnimplementedApiManageServer) ApiInfoDelete(context.Context, *WithID) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ApiInfoDelete not implemented")
}
func (UnimplementedApiManageServer) mustEmbedUnimplementedApiManageServer() {}

// UnsafeApiManageServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ApiManageServer will
// result in compilation errors.
type UnsafeApiManageServer interface {
	mustEmbedUnimplementedApiManageServer()
}

func RegisterApiManageServer(s grpc.ServiceRegistrar, srv ApiManageServer) {
	s.RegisterService(&ApiManage_ServiceDesc, srv)
}

func _ApiManage_ApiInfoCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApiInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiManageServer).ApiInfoCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ApiManage_ApiInfoCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiManageServer).ApiInfoCreate(ctx, req.(*ApiInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiManage_ApiInfoIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApiInfoIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiManageServer).ApiInfoIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ApiManage_ApiInfoIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiManageServer).ApiInfoIndex(ctx, req.(*ApiInfoIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiManage_ApiInfoUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApiInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiManageServer).ApiInfoUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ApiManage_ApiInfoUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiManageServer).ApiInfoUpdate(ctx, req.(*ApiInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiManage_ApiInfoDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiManageServer).ApiInfoDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ApiManage_ApiInfoDelete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiManageServer).ApiInfoDelete(ctx, req.(*WithID))
	}
	return interceptor(ctx, in, info, handler)
}

// ApiManage_ServiceDesc is the grpc.ServiceDesc for ApiManage service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ApiManage_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sys.ApiManage",
	HandlerType: (*ApiManageServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "apiInfoCreate",
			Handler:    _ApiManage_ApiInfoCreate_Handler,
		},
		{
			MethodName: "apiInfoIndex",
			Handler:    _ApiManage_ApiInfoIndex_Handler,
		},
		{
			MethodName: "apiInfoUpdate",
			Handler:    _ApiManage_ApiInfoUpdate_Handler,
		},
		{
			MethodName: "apiInfoDelete",
			Handler:    _ApiManage_ApiInfoDelete_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/sys.proto",
}

const (
	ProjectManage_ProjectInfoCreate_FullMethodName = "/sys.ProjectManage/projectInfoCreate"
	ProjectManage_ProjectInfoUpdate_FullMethodName = "/sys.ProjectManage/projectInfoUpdate"
	ProjectManage_ProjectInfoDelete_FullMethodName = "/sys.ProjectManage/projectInfoDelete"
	ProjectManage_ProjectInfoRead_FullMethodName   = "/sys.ProjectManage/projectInfoRead"
	ProjectManage_ProjectInfoIndex_FullMethodName  = "/sys.ProjectManage/projectInfoIndex"
)

// ProjectManageClient is the client API for ProjectManage service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ProjectManageClient interface {
	// 
	ProjectInfoCreate(ctx context.Context, in *ProjectInfo, opts ...grpc.CallOption) (*ProjectWithID, error)
	// 
	ProjectInfoUpdate(ctx context.Context, in *ProjectInfo, opts ...grpc.CallOption) (*Response, error)
	// 
	ProjectInfoDelete(ctx context.Context, in *ProjectWithID, opts ...grpc.CallOption) (*Response, error)
	// 
	ProjectInfoRead(ctx context.Context, in *ProjectWithID, opts ...grpc.CallOption) (*ProjectInfo, error)
	// 
	ProjectInfoIndex(ctx context.Context, in *ProjectInfoIndexReq, opts ...grpc.CallOption) (*ProjectInfoIndexResp, error)
}

type projectManageClient struct {
	cc grpc.ClientConnInterface
}

func NewProjectManageClient(cc grpc.ClientConnInterface) ProjectManageClient {
	return &projectManageClient{cc}
}

func (c *projectManageClient) ProjectInfoCreate(ctx context.Context, in *ProjectInfo, opts ...grpc.CallOption) (*ProjectWithID, error) {
	out := new(ProjectWithID)
	err := c.cc.Invoke(ctx, ProjectManage_ProjectInfoCreate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectManageClient) ProjectInfoUpdate(ctx context.Context, in *ProjectInfo, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, ProjectManage_ProjectInfoUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectManageClient) ProjectInfoDelete(ctx context.Context, in *ProjectWithID, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, ProjectManage_ProjectInfoDelete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectManageClient) ProjectInfoRead(ctx context.Context, in *ProjectWithID, opts ...grpc.CallOption) (*ProjectInfo, error) {
	out := new(ProjectInfo)
	err := c.cc.Invoke(ctx, ProjectManage_ProjectInfoRead_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectManageClient) ProjectInfoIndex(ctx context.Context, in *ProjectInfoIndexReq, opts ...grpc.CallOption) (*ProjectInfoIndexResp, error) {
	out := new(ProjectInfoIndexResp)
	err := c.cc.Invoke(ctx, ProjectManage_ProjectInfoIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ProjectManageServer is the server API for ProjectManage service.
// All implementations must embed UnimplementedProjectManageServer
// for forward compatibility
type ProjectManageServer interface {
	// 
	ProjectInfoCreate(context.Context, *ProjectInfo) (*ProjectWithID, error)
	// 
	ProjectInfoUpdate(context.Context, *ProjectInfo) (*Response, error)
	// 
	ProjectInfoDelete(context.Context, *ProjectWithID) (*Response, error)
	// 
	ProjectInfoRead(context.Context, *ProjectWithID) (*ProjectInfo, error)
	// 
	ProjectInfoIndex(context.Context, *ProjectInfoIndexReq) (*ProjectInfoIndexResp, error)
	mustEmbedUnimplementedProjectManageServer()
}

// UnimplementedProjectManageServer must be embedded to have forward compatible implementations.
type UnimplementedProjectManageServer struct {
}

func (UnimplementedProjectManageServer) ProjectInfoCreate(context.Context, *ProjectInfo) (*ProjectWithID, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProjectInfoCreate not implemented")
}
func (UnimplementedProjectManageServer) ProjectInfoUpdate(context.Context, *ProjectInfo) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProjectInfoUpdate not implemented")
}
func (UnimplementedProjectManageServer) ProjectInfoDelete(context.Context, *ProjectWithID) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProjectInfoDelete not implemented")
}
func (UnimplementedProjectManageServer) ProjectInfoRead(context.Context, *ProjectWithID) (*ProjectInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProjectInfoRead not implemented")
}
func (UnimplementedProjectManageServer) ProjectInfoIndex(context.Context, *ProjectInfoIndexReq) (*ProjectInfoIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProjectInfoIndex not implemented")
}
func (UnimplementedProjectManageServer) mustEmbedUnimplementedProjectManageServer() {}

// UnsafeProjectManageServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ProjectManageServer will
// result in compilation errors.
type UnsafeProjectManageServer interface {
	mustEmbedUnimplementedProjectManageServer()
}

func RegisterProjectManageServer(s grpc.ServiceRegistrar, srv ProjectManageServer) {
	s.RegisterService(&ProjectManage_ServiceDesc, srv)
}

func _ProjectManage_ProjectInfoCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProjectInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectManageServer).ProjectInfoCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProjectManage_ProjectInfoCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectManageServer).ProjectInfoCreate(ctx, req.(*ProjectInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProjectManage_ProjectInfoUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProjectInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectManageServer).ProjectInfoUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProjectManage_ProjectInfoUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectManageServer).ProjectInfoUpdate(ctx, req.(*ProjectInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProjectManage_ProjectInfoDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProjectWithID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectManageServer).ProjectInfoDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProjectManage_ProjectInfoDelete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectManageServer).ProjectInfoDelete(ctx, req.(*ProjectWithID))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProjectManage_ProjectInfoRead_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProjectWithID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectManageServer).ProjectInfoRead(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProjectManage_ProjectInfoRead_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectManageServer).ProjectInfoRead(ctx, req.(*ProjectWithID))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProjectManage_ProjectInfoIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProjectInfoIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectManageServer).ProjectInfoIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProjectManage_ProjectInfoIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectManageServer).ProjectInfoIndex(ctx, req.(*ProjectInfoIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

// ProjectManage_ServiceDesc is the grpc.ServiceDesc for ProjectManage service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ProjectManage_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sys.ProjectManage",
	HandlerType: (*ProjectManageServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "projectInfoCreate",
			Handler:    _ProjectManage_ProjectInfoCreate_Handler,
		},
		{
			MethodName: "projectInfoUpdate",
			Handler:    _ProjectManage_ProjectInfoUpdate_Handler,
		},
		{
			MethodName: "projectInfoDelete",
			Handler:    _ProjectManage_ProjectInfoDelete_Handler,
		},
		{
			MethodName: "projectInfoRead",
			Handler:    _ProjectManage_ProjectInfoRead_Handler,
		},
		{
			MethodName: "projectInfoIndex",
			Handler:    _ProjectManage_ProjectInfoIndex_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/sys.proto",
}

const (
	AreaManage_AreaInfoCreate_FullMethodName = "/sys.AreaManage/areaInfoCreate"
	AreaManage_AreaInfoUpdate_FullMethodName = "/sys.AreaManage/areaInfoUpdate"
	AreaManage_AreaInfoDelete_FullMethodName = "/sys.AreaManage/areaInfoDelete"
	AreaManage_AreaInfoRead_FullMethodName   = "/sys.AreaManage/areaInfoRead"
	AreaManage_AreaInfoIndex_FullMethodName  = "/sys.AreaManage/areaInfoIndex"
	AreaManage_AreaInfoTree_FullMethodName   = "/sys.AreaManage/areaInfoTree"
)

// AreaManageClient is the client API for AreaManage service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AreaManageClient interface {
	// 
	AreaInfoCreate(ctx context.Context, in *AreaInfo, opts ...grpc.CallOption) (*AreaWithID, error)
	// 
	AreaInfoUpdate(ctx context.Context, in *AreaInfo, opts ...grpc.CallOption) (*Response, error)
	// 
	AreaInfoDelete(ctx context.Context, in *AreaWithID, opts ...grpc.CallOption) (*Response, error)
	// 
	AreaInfoRead(ctx context.Context, in *AreaWithID, opts ...grpc.CallOption) (*AreaInfo, error)
	// 
	AreaInfoIndex(ctx context.Context, in *AreaInfoIndexReq, opts ...grpc.CallOption) (*AreaInfoIndexResp, error)
	// 
	AreaInfoTree(ctx context.Context, in *AreaInfoTreeReq, opts ...grpc.CallOption) (*AreaInfoTreeResp, error)
}

type areaManageClient struct {
	cc grpc.ClientConnInterface
}

func NewAreaManageClient(cc grpc.ClientConnInterface) AreaManageClient {
	return &areaManageClient{cc}
}

func (c *areaManageClient) AreaInfoCreate(ctx context.Context, in *AreaInfo, opts ...grpc.CallOption) (*AreaWithID, error) {
	out := new(AreaWithID)
	err := c.cc.Invoke(ctx, AreaManage_AreaInfoCreate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *areaManageClient) AreaInfoUpdate(ctx context.Context, in *AreaInfo, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, AreaManage_AreaInfoUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *areaManageClient) AreaInfoDelete(ctx context.Context, in *AreaWithID, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, AreaManage_AreaInfoDelete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *areaManageClient) AreaInfoRead(ctx context.Context, in *AreaWithID, opts ...grpc.CallOption) (*AreaInfo, error) {
	out := new(AreaInfo)
	err := c.cc.Invoke(ctx, AreaManage_AreaInfoRead_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *areaManageClient) AreaInfoIndex(ctx context.Context, in *AreaInfoIndexReq, opts ...grpc.CallOption) (*AreaInfoIndexResp, error) {
	out := new(AreaInfoIndexResp)
	err := c.cc.Invoke(ctx, AreaManage_AreaInfoIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *areaManageClient) AreaInfoTree(ctx context.Context, in *AreaInfoTreeReq, opts ...grpc.CallOption) (*AreaInfoTreeResp, error) {
	out := new(AreaInfoTreeResp)
	err := c.cc.Invoke(ctx, AreaManage_AreaInfoTree_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AreaManageServer is the server API for AreaManage service.
// All implementations must embed UnimplementedAreaManageServer
// for forward compatibility
type AreaManageServer interface {
	// 
	AreaInfoCreate(context.Context, *AreaInfo) (*AreaWithID, error)
	// 
	AreaInfoUpdate(context.Context, *AreaInfo) (*Response, error)
	// 
	AreaInfoDelete(context.Context, *AreaWithID) (*Response, error)
	// 
	AreaInfoRead(context.Context, *AreaWithID) (*AreaInfo, error)
	// 
	AreaInfoIndex(context.Context, *AreaInfoIndexReq) (*AreaInfoIndexResp, error)
	// 
	AreaInfoTree(context.Context, *AreaInfoTreeReq) (*AreaInfoTreeResp, error)
	mustEmbedUnimplementedAreaManageServer()
}

// UnimplementedAreaManageServer must be embedded to have forward compatible implementations.
type UnimplementedAreaManageServer struct {
}

func (UnimplementedAreaManageServer) AreaInfoCreate(context.Context, *AreaInfo) (*AreaWithID, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AreaInfoCreate not implemented")
}
func (UnimplementedAreaManageServer) AreaInfoUpdate(context.Context, *AreaInfo) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AreaInfoUpdate not implemented")
}
func (UnimplementedAreaManageServer) AreaInfoDelete(context.Context, *AreaWithID) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AreaInfoDelete not implemented")
}
func (UnimplementedAreaManageServer) AreaInfoRead(context.Context, *AreaWithID) (*AreaInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AreaInfoRead not implemented")
}
func (UnimplementedAreaManageServer) AreaInfoIndex(context.Context, *AreaInfoIndexReq) (*AreaInfoIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AreaInfoIndex not implemented")
}
func (UnimplementedAreaManageServer) AreaInfoTree(context.Context, *AreaInfoTreeReq) (*AreaInfoTreeResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AreaInfoTree not implemented")
}
func (UnimplementedAreaManageServer) mustEmbedUnimplementedAreaManageServer() {}

// UnsafeAreaManageServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AreaManageServer will
// result in compilation errors.
type UnsafeAreaManageServer interface {
	mustEmbedUnimplementedAreaManageServer()
}

func RegisterAreaManageServer(s grpc.ServiceRegistrar, srv AreaManageServer) {
	s.RegisterService(&AreaManage_ServiceDesc, srv)
}

func _AreaManage_AreaInfoCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AreaInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AreaManageServer).AreaInfoCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AreaManage_AreaInfoCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AreaManageServer).AreaInfoCreate(ctx, req.(*AreaInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _AreaManage_AreaInfoUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AreaInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AreaManageServer).AreaInfoUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AreaManage_AreaInfoUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AreaManageServer).AreaInfoUpdate(ctx, req.(*AreaInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _AreaManage_AreaInfoDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AreaWithID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AreaManageServer).AreaInfoDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AreaManage_AreaInfoDelete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AreaManageServer).AreaInfoDelete(ctx, req.(*AreaWithID))
	}
	return interceptor(ctx, in, info, handler)
}

func _AreaManage_AreaInfoRead_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AreaWithID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AreaManageServer).AreaInfoRead(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AreaManage_AreaInfoRead_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AreaManageServer).AreaInfoRead(ctx, req.(*AreaWithID))
	}
	return interceptor(ctx, in, info, handler)
}

func _AreaManage_AreaInfoIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AreaInfoIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AreaManageServer).AreaInfoIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AreaManage_AreaInfoIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AreaManageServer).AreaInfoIndex(ctx, req.(*AreaInfoIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _AreaManage_AreaInfoTree_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AreaInfoTreeReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AreaManageServer).AreaInfoTree(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AreaManage_AreaInfoTree_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AreaManageServer).AreaInfoTree(ctx, req.(*AreaInfoTreeReq))
	}
	return interceptor(ctx, in, info, handler)
}

// AreaManage_ServiceDesc is the grpc.ServiceDesc for AreaManage service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AreaManage_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sys.AreaManage",
	HandlerType: (*AreaManageServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "areaInfoCreate",
			Handler:    _AreaManage_AreaInfoCreate_Handler,
		},
		{
			MethodName: "areaInfoUpdate",
			Handler:    _AreaManage_AreaInfoUpdate_Handler,
		},
		{
			MethodName: "areaInfoDelete",
			Handler:    _AreaManage_AreaInfoDelete_Handler,
		},
		{
			MethodName: "areaInfoRead",
			Handler:    _AreaManage_AreaInfoRead_Handler,
		},
		{
			MethodName: "areaInfoIndex",
			Handler:    _AreaManage_AreaInfoIndex_Handler,
		},
		{
			MethodName: "areaInfoTree",
			Handler:    _AreaManage_AreaInfoTree_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/sys.proto",
}

const (
	TenantManage_TenantInfoCreate_FullMethodName           = "/sys.TenantManage/tenantInfoCreate"
	TenantManage_TenantInfoUpdate_FullMethodName           = "/sys.TenantManage/tenantInfoUpdate"
	TenantManage_TenantInfoDelete_FullMethodName           = "/sys.TenantManage/tenantInfoDelete"
	TenantManage_TenantInfoRead_FullMethodName             = "/sys.TenantManage/tenantInfoRead"
	TenantManage_TenantInfoIndex_FullMethodName            = "/sys.TenantManage/tenantInfoIndex"
	TenantManage_TenantAppIndex_FullMethodName             = "/sys.TenantManage/tenantAppIndex"
	TenantManage_TenantAppCreate_FullMethodName            = "/sys.TenantManage/tenantAppCreate"
	TenantManage_TenantAppDelete_FullMethodName            = "/sys.TenantManage/tenantAppDelete"
	TenantManage_TenantAppModuleMultiCreate_FullMethodName = "/sys.TenantManage/tenantAppModuleMultiCreate"
	TenantManage_TenantAppModuleCreate_FullMethodName      = "/sys.TenantManage/tenantAppModuleCreate"
	TenantManage_TenantAppModuleIndex_FullMethodName       = "/sys.TenantManage/tenantAppModuleIndex"
	TenantManage_TenantAppModuleDelete_FullMethodName      = "/sys.TenantManage/tenantAppModuleDelete"
	TenantManage_TenantAppMenuCreate_FullMethodName        = "/sys.TenantManage/tenantAppMenuCreate"
	TenantManage_TenantAppMenuIndex_FullMethodName         = "/sys.TenantManage/tenantAppMenuIndex"
	TenantManage_TenantAppMenuUpdate_FullMethodName        = "/sys.TenantManage/tenantAppMenuUpdate"
	TenantManage_TenantAppMenuDelete_FullMethodName        = "/sys.TenantManage/tenantAppMenuDelete"
	TenantManage_TenantAppApiCreate_FullMethodName         = "/sys.TenantManage/tenantAppApiCreate"
	TenantManage_TenantAppApiIndex_FullMethodName          = "/sys.TenantManage/tenantAppApiIndex"
	TenantManage_TenantAppApiUpdate_FullMethodName         = "/sys.TenantManage/tenantAppApiUpdate"
	TenantManage_TenantAppApiDelete_FullMethodName         = "/sys.TenantManage/tenantAppApiDelete"
)

// TenantManageClient is the client API for TenantManage service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TenantManageClient interface {
	// 
	TenantInfoCreate(ctx context.Context, in *TenantInfoCreateReq, opts ...grpc.CallOption) (*WithID, error)
	// 
	TenantInfoUpdate(ctx context.Context, in *TenantInfo, opts ...grpc.CallOption) (*Response, error)
	// 
	TenantInfoDelete(ctx context.Context, in *WithIDCode, opts ...grpc.CallOption) (*Response, error)
	// 
	TenantInfoRead(ctx context.Context, in *WithIDCode, opts ...grpc.CallOption) (*TenantInfo, error)
	// 
	TenantInfoIndex(ctx context.Context, in *TenantInfoIndexReq, opts ...grpc.CallOption) (*TenantInfoIndexResp, error)
	TenantAppIndex(ctx context.Context, in *TenantAppIndexReq, opts ...grpc.CallOption) (*TenantAppIndexResp, error)
	TenantAppCreate(ctx context.Context, in *TenantAppCreateReq, opts ...grpc.CallOption) (*Response, error)
	TenantAppDelete(ctx context.Context, in *TenantAppWithIDOrCode, opts ...grpc.CallOption) (*Response, error)
	TenantAppModuleMultiCreate(ctx context.Context, in *TenantAppCreateReq, opts ...grpc.CallOption) (*Response, error)
	TenantAppModuleCreate(ctx context.Context, in *TenantModuleCreateReq, opts ...grpc.CallOption) (*Response, error)
	TenantAppModuleIndex(ctx context.Context, in *TenantModuleIndexReq, opts ...grpc.CallOption) (*TenantModuleIndexResp, error)
	TenantAppModuleDelete(ctx context.Context, in *TenantModuleWithIDOrCode, opts ...grpc.CallOption) (*Response, error)
	TenantAppMenuCreate(ctx context.Context, in *TenantAppMenu, opts ...grpc.CallOption) (*WithID, error)
	TenantAppMenuIndex(ctx context.Context, in *TenantAppMenuIndexReq, opts ...grpc.CallOption) (*TenantAppMenuIndexResp, error)
	TenantAppMenuUpdate(ctx context.Context, in *TenantAppMenu, opts ...grpc.CallOption) (*Response, error)
	TenantAppMenuDelete(ctx context.Context, in *WithAppCodeID, opts ...grpc.CallOption) (*Response, error)
	TenantAppApiCreate(ctx context.Context, in *TenantApiInfo, opts ...grpc.CallOption) (*WithID, error)
	TenantAppApiIndex(ctx context.Context, in *TenantAppApiIndexReq, opts ...grpc.CallOption) (*TenantAppApiIndexResp, error)
	TenantAppApiUpdate(ctx context.Context, in *TenantApiInfo, opts ...grpc.CallOption) (*Response, error)
	TenantAppApiDelete(ctx context.Context, in *WithAppCodeID, opts ...grpc.CallOption) (*Response, error)
}

type tenantManageClient struct {
	cc grpc.ClientConnInterface
}

func NewTenantManageClient(cc grpc.ClientConnInterface) TenantManageClient {
	return &tenantManageClient{cc}
}

func (c *tenantManageClient) TenantInfoCreate(ctx context.Context, in *TenantInfoCreateReq, opts ...grpc.CallOption) (*WithID, error) {
	out := new(WithID)
	err := c.cc.Invoke(ctx, TenantManage_TenantInfoCreate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantManageClient) TenantInfoUpdate(ctx context.Context, in *TenantInfo, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, TenantManage_TenantInfoUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantManageClient) TenantInfoDelete(ctx context.Context, in *WithIDCode, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, TenantManage_TenantInfoDelete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantManageClient) TenantInfoRead(ctx context.Context, in *WithIDCode, opts ...grpc.CallOption) (*TenantInfo, error) {
	out := new(TenantInfo)
	err := c.cc.Invoke(ctx, TenantManage_TenantInfoRead_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantManageClient) TenantInfoIndex(ctx context.Context, in *TenantInfoIndexReq, opts ...grpc.CallOption) (*TenantInfoIndexResp, error) {
	out := new(TenantInfoIndexResp)
	err := c.cc.Invoke(ctx, TenantManage_TenantInfoIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantManageClient) TenantAppIndex(ctx context.Context, in *TenantAppIndexReq, opts ...grpc.CallOption) (*TenantAppIndexResp, error) {
	out := new(TenantAppIndexResp)
	err := c.cc.Invoke(ctx, TenantManage_TenantAppIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantManageClient) TenantAppCreate(ctx context.Context, in *TenantAppCreateReq, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, TenantManage_TenantAppCreate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantManageClient) TenantAppDelete(ctx context.Context, in *TenantAppWithIDOrCode, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, TenantManage_TenantAppDelete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantManageClient) TenantAppModuleMultiCreate(ctx context.Context, in *TenantAppCreateReq, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, TenantManage_TenantAppModuleMultiCreate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantManageClient) TenantAppModuleCreate(ctx context.Context, in *TenantModuleCreateReq, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, TenantManage_TenantAppModuleCreate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantManageClient) TenantAppModuleIndex(ctx context.Context, in *TenantModuleIndexReq, opts ...grpc.CallOption) (*TenantModuleIndexResp, error) {
	out := new(TenantModuleIndexResp)
	err := c.cc.Invoke(ctx, TenantManage_TenantAppModuleIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantManageClient) TenantAppModuleDelete(ctx context.Context, in *TenantModuleWithIDOrCode, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, TenantManage_TenantAppModuleDelete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantManageClient) TenantAppMenuCreate(ctx context.Context, in *TenantAppMenu, opts ...grpc.CallOption) (*WithID, error) {
	out := new(WithID)
	err := c.cc.Invoke(ctx, TenantManage_TenantAppMenuCreate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantManageClient) TenantAppMenuIndex(ctx context.Context, in *TenantAppMenuIndexReq, opts ...grpc.CallOption) (*TenantAppMenuIndexResp, error) {
	out := new(TenantAppMenuIndexResp)
	err := c.cc.Invoke(ctx, TenantManage_TenantAppMenuIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantManageClient) TenantAppMenuUpdate(ctx context.Context, in *TenantAppMenu, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, TenantManage_TenantAppMenuUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantManageClient) TenantAppMenuDelete(ctx context.Context, in *WithAppCodeID, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, TenantManage_TenantAppMenuDelete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantManageClient) TenantAppApiCreate(ctx context.Context, in *TenantApiInfo, opts ...grpc.CallOption) (*WithID, error) {
	out := new(WithID)
	err := c.cc.Invoke(ctx, TenantManage_TenantAppApiCreate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantManageClient) TenantAppApiIndex(ctx context.Context, in *TenantAppApiIndexReq, opts ...grpc.CallOption) (*TenantAppApiIndexResp, error) {
	out := new(TenantAppApiIndexResp)
	err := c.cc.Invoke(ctx, TenantManage_TenantAppApiIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantManageClient) TenantAppApiUpdate(ctx context.Context, in *TenantApiInfo, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, TenantManage_TenantAppApiUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantManageClient) TenantAppApiDelete(ctx context.Context, in *WithAppCodeID, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, TenantManage_TenantAppApiDelete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TenantManageServer is the server API for TenantManage service.
// All implementations must embed UnimplementedTenantManageServer
// for forward compatibility
type TenantManageServer interface {
	// 
	TenantInfoCreate(context.Context, *TenantInfoCreateReq) (*WithID, error)
	// 
	TenantInfoUpdate(context.Context, *TenantInfo) (*Response, error)
	// 
	TenantInfoDelete(context.Context, *WithIDCode) (*Response, error)
	// 
	TenantInfoRead(context.Context, *WithIDCode) (*TenantInfo, error)
	// 
	TenantInfoIndex(context.Context, *TenantInfoIndexReq) (*TenantInfoIndexResp, error)
	TenantAppIndex(context.Context, *TenantAppIndexReq) (*TenantAppIndexResp, error)
	TenantAppCreate(context.Context, *TenantAppCreateReq) (*Response, error)
	TenantAppDelete(context.Context, *TenantAppWithIDOrCode) (*Response, error)
	TenantAppModuleMultiCreate(context.Context, *TenantAppCreateReq) (*Response, error)
	TenantAppModuleCreate(context.Context, *TenantModuleCreateReq) (*Response, error)
	TenantAppModuleIndex(context.Context, *TenantModuleIndexReq) (*TenantModuleIndexResp, error)
	TenantAppModuleDelete(context.Context, *TenantModuleWithIDOrCode) (*Response, error)
	TenantAppMenuCreate(context.Context, *TenantAppMenu) (*WithID, error)
	TenantAppMenuIndex(context.Context, *TenantAppMenuIndexReq) (*TenantAppMenuIndexResp, error)
	TenantAppMenuUpdate(context.Context, *TenantAppMenu) (*Response, error)
	TenantAppMenuDelete(context.Context, *WithAppCodeID) (*Response, error)
	TenantAppApiCreate(context.Context, *TenantApiInfo) (*WithID, error)
	TenantAppApiIndex(context.Context, *TenantAppApiIndexReq) (*TenantAppApiIndexResp, error)
	TenantAppApiUpdate(context.Context, *TenantApiInfo) (*Response, error)
	TenantAppApiDelete(context.Context, *WithAppCodeID) (*Response, error)
	mustEmbedUnimplementedTenantManageServer()
}

// UnimplementedTenantManageServer must be embedded to have forward compatible implementations.
type UnimplementedTenantManageServer struct {
}

func (UnimplementedTenantManageServer) TenantInfoCreate(context.Context, *TenantInfoCreateReq) (*WithID, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TenantInfoCreate not implemented")
}
func (UnimplementedTenantManageServer) TenantInfoUpdate(context.Context, *TenantInfo) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TenantInfoUpdate not implemented")
}
func (UnimplementedTenantManageServer) TenantInfoDelete(context.Context, *WithIDCode) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TenantInfoDelete not implemented")
}
func (UnimplementedTenantManageServer) TenantInfoRead(context.Context, *WithIDCode) (*TenantInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TenantInfoRead not implemented")
}
func (UnimplementedTenantManageServer) TenantInfoIndex(context.Context, *TenantInfoIndexReq) (*TenantInfoIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TenantInfoIndex not implemented")
}
func (UnimplementedTenantManageServer) TenantAppIndex(context.Context, *TenantAppIndexReq) (*TenantAppIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TenantAppIndex not implemented")
}
func (UnimplementedTenantManageServer) TenantAppCreate(context.Context, *TenantAppCreateReq) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TenantAppCreate not implemented")
}
func (UnimplementedTenantManageServer) TenantAppDelete(context.Context, *TenantAppWithIDOrCode) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TenantAppDelete not implemented")
}
func (UnimplementedTenantManageServer) TenantAppModuleMultiCreate(context.Context, *TenantAppCreateReq) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TenantAppModuleMultiCreate not implemented")
}
func (UnimplementedTenantManageServer) TenantAppModuleCreate(context.Context, *TenantModuleCreateReq) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TenantAppModuleCreate not implemented")
}
func (UnimplementedTenantManageServer) TenantAppModuleIndex(context.Context, *TenantModuleIndexReq) (*TenantModuleIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TenantAppModuleIndex not implemented")
}
func (UnimplementedTenantManageServer) TenantAppModuleDelete(context.Context, *TenantModuleWithIDOrCode) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TenantAppModuleDelete not implemented")
}
func (UnimplementedTenantManageServer) TenantAppMenuCreate(context.Context, *TenantAppMenu) (*WithID, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TenantAppMenuCreate not implemented")
}
func (UnimplementedTenantManageServer) TenantAppMenuIndex(context.Context, *TenantAppMenuIndexReq) (*TenantAppMenuIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TenantAppMenuIndex not implemented")
}
func (UnimplementedTenantManageServer) TenantAppMenuUpdate(context.Context, *TenantAppMenu) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TenantAppMenuUpdate not implemented")
}
func (UnimplementedTenantManageServer) TenantAppMenuDelete(context.Context, *WithAppCodeID) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TenantAppMenuDelete not implemented")
}
func (UnimplementedTenantManageServer) TenantAppApiCreate(context.Context, *TenantApiInfo) (*WithID, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TenantAppApiCreate not implemented")
}
func (UnimplementedTenantManageServer) TenantAppApiIndex(context.Context, *TenantAppApiIndexReq) (*TenantAppApiIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TenantAppApiIndex not implemented")
}
func (UnimplementedTenantManageServer) TenantAppApiUpdate(context.Context, *TenantApiInfo) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TenantAppApiUpdate not implemented")
}
func (UnimplementedTenantManageServer) TenantAppApiDelete(context.Context, *WithAppCodeID) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TenantAppApiDelete not implemented")
}
func (UnimplementedTenantManageServer) mustEmbedUnimplementedTenantManageServer() {}

// UnsafeTenantManageServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TenantManageServer will
// result in compilation errors.
type UnsafeTenantManageServer interface {
	mustEmbedUnimplementedTenantManageServer()
}

func RegisterTenantManageServer(s grpc.ServiceRegistrar, srv TenantManageServer) {
	s.RegisterService(&TenantManage_ServiceDesc, srv)
}

func _TenantManage_TenantInfoCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TenantInfoCreateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantManageServer).TenantInfoCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantManage_TenantInfoCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantManageServer).TenantInfoCreate(ctx, req.(*TenantInfoCreateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantManage_TenantInfoUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TenantInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantManageServer).TenantInfoUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantManage_TenantInfoUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantManageServer).TenantInfoUpdate(ctx, req.(*TenantInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantManage_TenantInfoDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithIDCode)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantManageServer).TenantInfoDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantManage_TenantInfoDelete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantManageServer).TenantInfoDelete(ctx, req.(*WithIDCode))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantManage_TenantInfoRead_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithIDCode)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantManageServer).TenantInfoRead(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantManage_TenantInfoRead_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantManageServer).TenantInfoRead(ctx, req.(*WithIDCode))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantManage_TenantInfoIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TenantInfoIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantManageServer).TenantInfoIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantManage_TenantInfoIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantManageServer).TenantInfoIndex(ctx, req.(*TenantInfoIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantManage_TenantAppIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TenantAppIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantManageServer).TenantAppIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantManage_TenantAppIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantManageServer).TenantAppIndex(ctx, req.(*TenantAppIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantManage_TenantAppCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TenantAppCreateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantManageServer).TenantAppCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantManage_TenantAppCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantManageServer).TenantAppCreate(ctx, req.(*TenantAppCreateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantManage_TenantAppDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TenantAppWithIDOrCode)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantManageServer).TenantAppDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantManage_TenantAppDelete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantManageServer).TenantAppDelete(ctx, req.(*TenantAppWithIDOrCode))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantManage_TenantAppModuleMultiCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TenantAppCreateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantManageServer).TenantAppModuleMultiCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantManage_TenantAppModuleMultiCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantManageServer).TenantAppModuleMultiCreate(ctx, req.(*TenantAppCreateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantManage_TenantAppModuleCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TenantModuleCreateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantManageServer).TenantAppModuleCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantManage_TenantAppModuleCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantManageServer).TenantAppModuleCreate(ctx, req.(*TenantModuleCreateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantManage_TenantAppModuleIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TenantModuleIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantManageServer).TenantAppModuleIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantManage_TenantAppModuleIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantManageServer).TenantAppModuleIndex(ctx, req.(*TenantModuleIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantManage_TenantAppModuleDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TenantModuleWithIDOrCode)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantManageServer).TenantAppModuleDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantManage_TenantAppModuleDelete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantManageServer).TenantAppModuleDelete(ctx, req.(*TenantModuleWithIDOrCode))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantManage_TenantAppMenuCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TenantAppMenu)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantManageServer).TenantAppMenuCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantManage_TenantAppMenuCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantManageServer).TenantAppMenuCreate(ctx, req.(*TenantAppMenu))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantManage_TenantAppMenuIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TenantAppMenuIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantManageServer).TenantAppMenuIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantManage_TenantAppMenuIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantManageServer).TenantAppMenuIndex(ctx, req.(*TenantAppMenuIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantManage_TenantAppMenuUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TenantAppMenu)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantManageServer).TenantAppMenuUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantManage_TenantAppMenuUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantManageServer).TenantAppMenuUpdate(ctx, req.(*TenantAppMenu))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantManage_TenantAppMenuDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithAppCodeID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantManageServer).TenantAppMenuDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantManage_TenantAppMenuDelete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantManageServer).TenantAppMenuDelete(ctx, req.(*WithAppCodeID))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantManage_TenantAppApiCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TenantApiInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantManageServer).TenantAppApiCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantManage_TenantAppApiCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantManageServer).TenantAppApiCreate(ctx, req.(*TenantApiInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantManage_TenantAppApiIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TenantAppApiIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantManageServer).TenantAppApiIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantManage_TenantAppApiIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantManageServer).TenantAppApiIndex(ctx, req.(*TenantAppApiIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantManage_TenantAppApiUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TenantApiInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantManageServer).TenantAppApiUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantManage_TenantAppApiUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantManageServer).TenantAppApiUpdate(ctx, req.(*TenantApiInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantManage_TenantAppApiDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithAppCodeID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantManageServer).TenantAppApiDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantManage_TenantAppApiDelete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantManageServer).TenantAppApiDelete(ctx, req.(*WithAppCodeID))
	}
	return interceptor(ctx, in, info, handler)
}

// TenantManage_ServiceDesc is the grpc.ServiceDesc for TenantManage service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TenantManage_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sys.TenantManage",
	HandlerType: (*TenantManageServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "tenantInfoCreate",
			Handler:    _TenantManage_TenantInfoCreate_Handler,
		},
		{
			MethodName: "tenantInfoUpdate",
			Handler:    _TenantManage_TenantInfoUpdate_Handler,
		},
		{
			MethodName: "tenantInfoDelete",
			Handler:    _TenantManage_TenantInfoDelete_Handler,
		},
		{
			MethodName: "tenantInfoRead",
			Handler:    _TenantManage_TenantInfoRead_Handler,
		},
		{
			MethodName: "tenantInfoIndex",
			Handler:    _TenantManage_TenantInfoIndex_Handler,
		},
		{
			MethodName: "tenantAppIndex",
			Handler:    _TenantManage_TenantAppIndex_Handler,
		},
		{
			MethodName: "tenantAppCreate",
			Handler:    _TenantManage_TenantAppCreate_Handler,
		},
		{
			MethodName: "tenantAppDelete",
			Handler:    _TenantManage_TenantAppDelete_Handler,
		},
		{
			MethodName: "tenantAppModuleMultiCreate",
			Handler:    _TenantManage_TenantAppModuleMultiCreate_Handler,
		},
		{
			MethodName: "tenantAppModuleCreate",
			Handler:    _TenantManage_TenantAppModuleCreate_Handler,
		},
		{
			MethodName: "tenantAppModuleIndex",
			Handler:    _TenantManage_TenantAppModuleIndex_Handler,
		},
		{
			MethodName: "tenantAppModuleDelete",
			Handler:    _TenantManage_TenantAppModuleDelete_Handler,
		},
		{
			MethodName: "tenantAppMenuCreate",
			Handler:    _TenantManage_TenantAppMenuCreate_Handler,
		},
		{
			MethodName: "tenantAppMenuIndex",
			Handler:    _TenantManage_TenantAppMenuIndex_Handler,
		},
		{
			MethodName: "tenantAppMenuUpdate",
			Handler:    _TenantManage_TenantAppMenuUpdate_Handler,
		},
		{
			MethodName: "tenantAppMenuDelete",
			Handler:    _TenantManage_TenantAppMenuDelete_Handler,
		},
		{
			MethodName: "tenantAppApiCreate",
			Handler:    _TenantManage_TenantAppApiCreate_Handler,
		},
		{
			MethodName: "tenantAppApiIndex",
			Handler:    _TenantManage_TenantAppApiIndex_Handler,
		},
		{
			MethodName: "tenantAppApiUpdate",
			Handler:    _TenantManage_TenantAppApiUpdate_Handler,
		},
		{
			MethodName: "tenantAppApiDelete",
			Handler:    _TenantManage_TenantAppApiDelete_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/sys.proto",
}
