// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v3.19.4
// source: proto/sys.proto

package sys

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	UserManage_UserInfoCreate_FullMethodName             = "/sys.UserManage/userInfoCreate"
	UserManage_UserInfoIndex_FullMethodName              = "/sys.UserManage/userInfoIndex"
	UserManage_UserInfoUpdate_FullMethodName             = "/sys.UserManage/userInfoUpdate"
	UserManage_UserInfoRead_FullMethodName               = "/sys.UserManage/userInfoRead"
	UserManage_UserInfoDelete_FullMethodName             = "/sys.UserManage/userInfoDelete"
	UserManage_UserLogin_FullMethodName                  = "/sys.UserManage/userLogin"
	UserManage_UserCheckToken_FullMethodName             = "/sys.UserManage/userCheckToken"
	UserManage_UserRegister1_FullMethodName              = "/sys.UserManage/userRegister1"
	UserManage_UserRegister2_FullMethodName              = "/sys.UserManage/userRegister2"
	UserManage_UserRoleIndex_FullMethodName              = "/sys.UserManage/userRoleIndex"
	UserManage_UserRoleMultiUpdate_FullMethodName        = "/sys.UserManage/userRoleMultiUpdate"
	UserManage_UserAuthProjectMultiUpdate_FullMethodName = "/sys.UserManage/userAuthProjectMultiUpdate"
	UserManage_UserAuthProjectIndex_FullMethodName       = "/sys.UserManage/userAuthProjectIndex"
	UserManage_UserAuthAreaMultiUpdate_FullMethodName    = "/sys.UserManage/userAuthAreaMultiUpdate"
	UserManage_UserAuthAreaIndex_FullMethodName          = "/sys.UserManage/userAuthAreaIndex"
)

// UserManageClient is the client API for UserManage service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UserManageClient interface {
	UserInfoCreate(ctx context.Context, in *UserInfo, opts ...grpc.CallOption) (*UserCreateResp, error)
	UserInfoIndex(ctx context.Context, in *UserInfoIndexReq, opts ...grpc.CallOption) (*UserInfoIndexResp, error)
	UserInfoUpdate(ctx context.Context, in *UserInfo, opts ...grpc.CallOption) (*Response, error)
	UserInfoRead(ctx context.Context, in *UserInfoReadReq, opts ...grpc.CallOption) (*UserInfo, error)
	UserInfoDelete(ctx context.Context, in *UserInfoDeleteReq, opts ...grpc.CallOption) (*Response, error)
	UserLogin(ctx context.Context, in *UserLoginReq, opts ...grpc.CallOption) (*UserLoginResp, error)
	UserCheckToken(ctx context.Context, in *UserCheckTokenReq, opts ...grpc.CallOption) (*UserCheckTokenResp, error)
	UserRegister1(ctx context.Context, in *UserRegister1Req, opts ...grpc.CallOption) (*UserRegister1Resp, error)
	UserRegister2(ctx context.Context, in *UserRegister2Req, opts ...grpc.CallOption) (*Response, error)
	UserRoleIndex(ctx context.Context, in *UserRoleIndexReq, opts ...grpc.CallOption) (*UserRoleIndexResp, error)
	UserRoleMultiUpdate(ctx context.Context, in *UserRoleMultiUpdateReq, opts ...grpc.CallOption) (*Response, error)
	UserAuthProjectMultiUpdate(ctx context.Context, in *UserAuthProjectMultiUpdateReq, opts ...grpc.CallOption) (*Response, error)
	UserAuthProjectIndex(ctx context.Context, in *UserAuthProjectIndexReq, opts ...grpc.CallOption) (*UserAuthProjectIndexResp, error)
	UserAuthAreaMultiUpdate(ctx context.Context, in *UserAuthAreaMultiUpdateReq, opts ...grpc.CallOption) (*Response, error)
	UserAuthAreaIndex(ctx context.Context, in *UserAuthAreaIndexReq, opts ...grpc.CallOption) (*UserAuthAreaIndexResp, error)
}

type userManageClient struct {
	cc grpc.ClientConnInterface
}

func NewUserManageClient(cc grpc.ClientConnInterface) UserManageClient {
	return &userManageClient{cc}
}

func (c *userManageClient) UserInfoCreate(ctx context.Context, in *UserInfo, opts ...grpc.CallOption) (*UserCreateResp, error) {
	out := new(UserCreateResp)
	err := c.cc.Invoke(ctx, UserManage_UserInfoCreate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userManageClient) UserInfoIndex(ctx context.Context, in *UserInfoIndexReq, opts ...grpc.CallOption) (*UserInfoIndexResp, error) {
	out := new(UserInfoIndexResp)
	err := c.cc.Invoke(ctx, UserManage_UserInfoIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userManageClient) UserInfoUpdate(ctx context.Context, in *UserInfo, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, UserManage_UserInfoUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userManageClient) UserInfoRead(ctx context.Context, in *UserInfoReadReq, opts ...grpc.CallOption) (*UserInfo, error) {
	out := new(UserInfo)
	err := c.cc.Invoke(ctx, UserManage_UserInfoRead_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userManageClient) UserInfoDelete(ctx context.Context, in *UserInfoDeleteReq, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, UserManage_UserInfoDelete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userManageClient) UserLogin(ctx context.Context, in *UserLoginReq, opts ...grpc.CallOption) (*UserLoginResp, error) {
	out := new(UserLoginResp)
	err := c.cc.Invoke(ctx, UserManage_UserLogin_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userManageClient) UserCheckToken(ctx context.Context, in *UserCheckTokenReq, opts ...grpc.CallOption) (*UserCheckTokenResp, error) {
	out := new(UserCheckTokenResp)
	err := c.cc.Invoke(ctx, UserManage_UserCheckToken_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userManageClient) UserRegister1(ctx context.Context, in *UserRegister1Req, opts ...grpc.CallOption) (*UserRegister1Resp, error) {
	out := new(UserRegister1Resp)
	err := c.cc.Invoke(ctx, UserManage_UserRegister1_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userManageClient) UserRegister2(ctx context.Context, in *UserRegister2Req, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, UserManage_UserRegister2_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userManageClient) UserRoleIndex(ctx context.Context, in *UserRoleIndexReq, opts ...grpc.CallOption) (*UserRoleIndexResp, error) {
	out := new(UserRoleIndexResp)
	err := c.cc.Invoke(ctx, UserManage_UserRoleIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userManageClient) UserRoleMultiUpdate(ctx context.Context, in *UserRoleMultiUpdateReq, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, UserManage_UserRoleMultiUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userManageClient) UserAuthProjectMultiUpdate(ctx context.Context, in *UserAuthProjectMultiUpdateReq, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, UserManage_UserAuthProjectMultiUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userManageClient) UserAuthProjectIndex(ctx context.Context, in *UserAuthProjectIndexReq, opts ...grpc.CallOption) (*UserAuthProjectIndexResp, error) {
	out := new(UserAuthProjectIndexResp)
	err := c.cc.Invoke(ctx, UserManage_UserAuthProjectIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userManageClient) UserAuthAreaMultiUpdate(ctx context.Context, in *UserAuthAreaMultiUpdateReq, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, UserManage_UserAuthAreaMultiUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *userManageClient) UserAuthAreaIndex(ctx context.Context, in *UserAuthAreaIndexReq, opts ...grpc.CallOption) (*UserAuthAreaIndexResp, error) {
	out := new(UserAuthAreaIndexResp)
	err := c.cc.Invoke(ctx, UserManage_UserAuthAreaIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UserManageServer is the server API for UserManage service.
// All implementations must embed UnimplementedUserManageServer
// for forward compatibility
type UserManageServer interface {
	UserInfoCreate(context.Context, *UserInfo) (*UserCreateResp, error)
	UserInfoIndex(context.Context, *UserInfoIndexReq) (*UserInfoIndexResp, error)
	UserInfoUpdate(context.Context, *UserInfo) (*Response, error)
	UserInfoRead(context.Context, *UserInfoReadReq) (*UserInfo, error)
	UserInfoDelete(context.Context, *UserInfoDeleteReq) (*Response, error)
	UserLogin(context.Context, *UserLoginReq) (*UserLoginResp, error)
	UserCheckToken(context.Context, *UserCheckTokenReq) (*UserCheckTokenResp, error)
	UserRegister1(context.Context, *UserRegister1Req) (*UserRegister1Resp, error)
	UserRegister2(context.Context, *UserRegister2Req) (*Response, error)
	UserRoleIndex(context.Context, *UserRoleIndexReq) (*UserRoleIndexResp, error)
	UserRoleMultiUpdate(context.Context, *UserRoleMultiUpdateReq) (*Response, error)
	UserAuthProjectMultiUpdate(context.Context, *UserAuthProjectMultiUpdateReq) (*Response, error)
	UserAuthProjectIndex(context.Context, *UserAuthProjectIndexReq) (*UserAuthProjectIndexResp, error)
	UserAuthAreaMultiUpdate(context.Context, *UserAuthAreaMultiUpdateReq) (*Response, error)
	UserAuthAreaIndex(context.Context, *UserAuthAreaIndexReq) (*UserAuthAreaIndexResp, error)
	mustEmbedUnimplementedUserManageServer()
}

// UnimplementedUserManageServer must be embedded to have forward compatible implementations.
type UnimplementedUserManageServer struct {
}

func (UnimplementedUserManageServer) UserInfoCreate(context.Context, *UserInfo) (*UserCreateResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserInfoCreate not implemented")
}
func (UnimplementedUserManageServer) UserInfoIndex(context.Context, *UserInfoIndexReq) (*UserInfoIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserInfoIndex not implemented")
}
func (UnimplementedUserManageServer) UserInfoUpdate(context.Context, *UserInfo) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserInfoUpdate not implemented")
}
func (UnimplementedUserManageServer) UserInfoRead(context.Context, *UserInfoReadReq) (*UserInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserInfoRead not implemented")
}
func (UnimplementedUserManageServer) UserInfoDelete(context.Context, *UserInfoDeleteReq) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserInfoDelete not implemented")
}
func (UnimplementedUserManageServer) UserLogin(context.Context, *UserLoginReq) (*UserLoginResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserLogin not implemented")
}
func (UnimplementedUserManageServer) UserCheckToken(context.Context, *UserCheckTokenReq) (*UserCheckTokenResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserCheckToken not implemented")
}
func (UnimplementedUserManageServer) UserRegister1(context.Context, *UserRegister1Req) (*UserRegister1Resp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserRegister1 not implemented")
}
func (UnimplementedUserManageServer) UserRegister2(context.Context, *UserRegister2Req) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserRegister2 not implemented")
}
func (UnimplementedUserManageServer) UserRoleIndex(context.Context, *UserRoleIndexReq) (*UserRoleIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserRoleIndex not implemented")
}
func (UnimplementedUserManageServer) UserRoleMultiUpdate(context.Context, *UserRoleMultiUpdateReq) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserRoleMultiUpdate not implemented")
}
func (UnimplementedUserManageServer) UserAuthProjectMultiUpdate(context.Context, *UserAuthProjectMultiUpdateReq) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserAuthProjectMultiUpdate not implemented")
}
func (UnimplementedUserManageServer) UserAuthProjectIndex(context.Context, *UserAuthProjectIndexReq) (*UserAuthProjectIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserAuthProjectIndex not implemented")
}
func (UnimplementedUserManageServer) UserAuthAreaMultiUpdate(context.Context, *UserAuthAreaMultiUpdateReq) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserAuthAreaMultiUpdate not implemented")
}
func (UnimplementedUserManageServer) UserAuthAreaIndex(context.Context, *UserAuthAreaIndexReq) (*UserAuthAreaIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UserAuthAreaIndex not implemented")
}
func (UnimplementedUserManageServer) mustEmbedUnimplementedUserManageServer() {}

// UnsafeUserManageServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UserManageServer will
// result in compilation errors.
type UnsafeUserManageServer interface {
	mustEmbedUnimplementedUserManageServer()
}

func RegisterUserManageServer(s grpc.ServiceRegistrar, srv UserManageServer) {
	s.RegisterService(&UserManage_ServiceDesc, srv)
}

func _UserManage_UserInfoCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserManageServer).UserInfoCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserManage_UserInfoCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserManageServer).UserInfoCreate(ctx, req.(*UserInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserManage_UserInfoIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserInfoIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserManageServer).UserInfoIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserManage_UserInfoIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserManageServer).UserInfoIndex(ctx, req.(*UserInfoIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserManage_UserInfoUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserManageServer).UserInfoUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserManage_UserInfoUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserManageServer).UserInfoUpdate(ctx, req.(*UserInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserManage_UserInfoRead_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserInfoReadReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserManageServer).UserInfoRead(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserManage_UserInfoRead_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserManageServer).UserInfoRead(ctx, req.(*UserInfoReadReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserManage_UserInfoDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserInfoDeleteReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserManageServer).UserInfoDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserManage_UserInfoDelete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserManageServer).UserInfoDelete(ctx, req.(*UserInfoDeleteReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserManage_UserLogin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserLoginReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserManageServer).UserLogin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserManage_UserLogin_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserManageServer).UserLogin(ctx, req.(*UserLoginReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserManage_UserCheckToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserCheckTokenReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserManageServer).UserCheckToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserManage_UserCheckToken_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserManageServer).UserCheckToken(ctx, req.(*UserCheckTokenReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserManage_UserRegister1_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserRegister1Req)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserManageServer).UserRegister1(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserManage_UserRegister1_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserManageServer).UserRegister1(ctx, req.(*UserRegister1Req))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserManage_UserRegister2_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserRegister2Req)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserManageServer).UserRegister2(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserManage_UserRegister2_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserManageServer).UserRegister2(ctx, req.(*UserRegister2Req))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserManage_UserRoleIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserRoleIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserManageServer).UserRoleIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserManage_UserRoleIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserManageServer).UserRoleIndex(ctx, req.(*UserRoleIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserManage_UserRoleMultiUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserRoleMultiUpdateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserManageServer).UserRoleMultiUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserManage_UserRoleMultiUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserManageServer).UserRoleMultiUpdate(ctx, req.(*UserRoleMultiUpdateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserManage_UserAuthProjectMultiUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserAuthProjectMultiUpdateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserManageServer).UserAuthProjectMultiUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserManage_UserAuthProjectMultiUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserManageServer).UserAuthProjectMultiUpdate(ctx, req.(*UserAuthProjectMultiUpdateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserManage_UserAuthProjectIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserAuthProjectIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserManageServer).UserAuthProjectIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserManage_UserAuthProjectIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserManageServer).UserAuthProjectIndex(ctx, req.(*UserAuthProjectIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserManage_UserAuthAreaMultiUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserAuthAreaMultiUpdateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserManageServer).UserAuthAreaMultiUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserManage_UserAuthAreaMultiUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserManageServer).UserAuthAreaMultiUpdate(ctx, req.(*UserAuthAreaMultiUpdateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UserManage_UserAuthAreaIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserAuthAreaIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UserManageServer).UserAuthAreaIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UserManage_UserAuthAreaIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UserManageServer).UserAuthAreaIndex(ctx, req.(*UserAuthAreaIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

// UserManage_ServiceDesc is the grpc.ServiceDesc for UserManage service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UserManage_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sys.UserManage",
	HandlerType: (*UserManageServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "userInfoCreate",
			Handler:    _UserManage_UserInfoCreate_Handler,
		},
		{
			MethodName: "userInfoIndex",
			Handler:    _UserManage_UserInfoIndex_Handler,
		},
		{
			MethodName: "userInfoUpdate",
			Handler:    _UserManage_UserInfoUpdate_Handler,
		},
		{
			MethodName: "userInfoRead",
			Handler:    _UserManage_UserInfoRead_Handler,
		},
		{
			MethodName: "userInfoDelete",
			Handler:    _UserManage_UserInfoDelete_Handler,
		},
		{
			MethodName: "userLogin",
			Handler:    _UserManage_UserLogin_Handler,
		},
		{
			MethodName: "userCheckToken",
			Handler:    _UserManage_UserCheckToken_Handler,
		},
		{
			MethodName: "userRegister1",
			Handler:    _UserManage_UserRegister1_Handler,
		},
		{
			MethodName: "userRegister2",
			Handler:    _UserManage_UserRegister2_Handler,
		},
		{
			MethodName: "userRoleIndex",
			Handler:    _UserManage_UserRoleIndex_Handler,
		},
		{
			MethodName: "userRoleMultiUpdate",
			Handler:    _UserManage_UserRoleMultiUpdate_Handler,
		},
		{
			MethodName: "userAuthProjectMultiUpdate",
			Handler:    _UserManage_UserAuthProjectMultiUpdate_Handler,
		},
		{
			MethodName: "userAuthProjectIndex",
			Handler:    _UserManage_UserAuthProjectIndex_Handler,
		},
		{
			MethodName: "userAuthAreaMultiUpdate",
			Handler:    _UserManage_UserAuthAreaMultiUpdate_Handler,
		},
		{
			MethodName: "userAuthAreaIndex",
			Handler:    _UserManage_UserAuthAreaIndex_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/sys.proto",
}

const (
	RoleManage_RoleInfoCreate_FullMethodName      = "/sys.RoleManage/roleInfoCreate"
	RoleManage_RoleInfoIndex_FullMethodName       = "/sys.RoleManage/roleInfoIndex"
	RoleManage_RoleInfoUpdate_FullMethodName      = "/sys.RoleManage/roleInfoUpdate"
	RoleManage_RoleInfoDelete_FullMethodName      = "/sys.RoleManage/roleInfoDelete"
	RoleManage_RoleMenuIndex_FullMethodName       = "/sys.RoleManage/roleMenuIndex"
	RoleManage_RoleMenuMultiUpdate_FullMethodName = "/sys.RoleManage/roleMenuMultiUpdate"
	RoleManage_RoleAppIndex_FullMethodName        = "/sys.RoleManage/roleAppIndex"
	RoleManage_RoleAppMultiUpdate_FullMethodName  = "/sys.RoleManage/roleAppMultiUpdate"
	RoleManage_RoleApiAuth_FullMethodName         = "/sys.RoleManage/roleApiAuth"
	RoleManage_RoleApiMultiUpdate_FullMethodName  = "/sys.RoleManage/roleApiMultiUpdate"
	RoleManage_RoleApiIndex_FullMethodName        = "/sys.RoleManage/roleApiIndex"
)

// RoleManageClient is the client API for RoleManage service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RoleManageClient interface {
	RoleInfoCreate(ctx context.Context, in *RoleInfo, opts ...grpc.CallOption) (*Response, error)
	RoleInfoIndex(ctx context.Context, in *RoleInfoIndexReq, opts ...grpc.CallOption) (*RoleInfoIndexResp, error)
	RoleInfoUpdate(ctx context.Context, in *RoleInfo, opts ...grpc.CallOption) (*Response, error)
	RoleInfoDelete(ctx context.Context, in *ReqWithID, opts ...grpc.CallOption) (*Response, error)
	RoleMenuIndex(ctx context.Context, in *RoleMenuIndexReq, opts ...grpc.CallOption) (*RoleMenuIndexResp, error)
	RoleMenuMultiUpdate(ctx context.Context, in *RoleMenuMultiUpdateReq, opts ...grpc.CallOption) (*Response, error)
	RoleAppIndex(ctx context.Context, in *RoleAppIndexReq, opts ...grpc.CallOption) (*RoleAppIndexResp, error)
	RoleAppMultiUpdate(ctx context.Context, in *RoleAppMultiUpdateReq, opts ...grpc.CallOption) (*Response, error)
	RoleApiAuth(ctx context.Context, in *RoleApiAuthReq, opts ...grpc.CallOption) (*Response, error)
	RoleApiMultiUpdate(ctx context.Context, in *RoleApiMultiUpdateReq, opts ...grpc.CallOption) (*Response, error)
	RoleApiIndex(ctx context.Context, in *RoleApiIndexReq, opts ...grpc.CallOption) (*RoleApiIndexResp, error)
}

type roleManageClient struct {
	cc grpc.ClientConnInterface
}

func NewRoleManageClient(cc grpc.ClientConnInterface) RoleManageClient {
	return &roleManageClient{cc}
}

func (c *roleManageClient) RoleInfoCreate(ctx context.Context, in *RoleInfo, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, RoleManage_RoleInfoCreate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleManageClient) RoleInfoIndex(ctx context.Context, in *RoleInfoIndexReq, opts ...grpc.CallOption) (*RoleInfoIndexResp, error) {
	out := new(RoleInfoIndexResp)
	err := c.cc.Invoke(ctx, RoleManage_RoleInfoIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleManageClient) RoleInfoUpdate(ctx context.Context, in *RoleInfo, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, RoleManage_RoleInfoUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleManageClient) RoleInfoDelete(ctx context.Context, in *ReqWithID, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, RoleManage_RoleInfoDelete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleManageClient) RoleMenuIndex(ctx context.Context, in *RoleMenuIndexReq, opts ...grpc.CallOption) (*RoleMenuIndexResp, error) {
	out := new(RoleMenuIndexResp)
	err := c.cc.Invoke(ctx, RoleManage_RoleMenuIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleManageClient) RoleMenuMultiUpdate(ctx context.Context, in *RoleMenuMultiUpdateReq, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, RoleManage_RoleMenuMultiUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleManageClient) RoleAppIndex(ctx context.Context, in *RoleAppIndexReq, opts ...grpc.CallOption) (*RoleAppIndexResp, error) {
	out := new(RoleAppIndexResp)
	err := c.cc.Invoke(ctx, RoleManage_RoleAppIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleManageClient) RoleAppMultiUpdate(ctx context.Context, in *RoleAppMultiUpdateReq, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, RoleManage_RoleAppMultiUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleManageClient) RoleApiAuth(ctx context.Context, in *RoleApiAuthReq, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, RoleManage_RoleApiAuth_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleManageClient) RoleApiMultiUpdate(ctx context.Context, in *RoleApiMultiUpdateReq, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, RoleManage_RoleApiMultiUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *roleManageClient) RoleApiIndex(ctx context.Context, in *RoleApiIndexReq, opts ...grpc.CallOption) (*RoleApiIndexResp, error) {
	out := new(RoleApiIndexResp)
	err := c.cc.Invoke(ctx, RoleManage_RoleApiIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RoleManageServer is the server API for RoleManage service.
// All implementations must embed UnimplementedRoleManageServer
// for forward compatibility
type RoleManageServer interface {
	RoleInfoCreate(context.Context, *RoleInfo) (*Response, error)
	RoleInfoIndex(context.Context, *RoleInfoIndexReq) (*RoleInfoIndexResp, error)
	RoleInfoUpdate(context.Context, *RoleInfo) (*Response, error)
	RoleInfoDelete(context.Context, *ReqWithID) (*Response, error)
	RoleMenuIndex(context.Context, *RoleMenuIndexReq) (*RoleMenuIndexResp, error)
	RoleMenuMultiUpdate(context.Context, *RoleMenuMultiUpdateReq) (*Response, error)
	RoleAppIndex(context.Context, *RoleAppIndexReq) (*RoleAppIndexResp, error)
	RoleAppMultiUpdate(context.Context, *RoleAppMultiUpdateReq) (*Response, error)
	RoleApiAuth(context.Context, *RoleApiAuthReq) (*Response, error)
	RoleApiMultiUpdate(context.Context, *RoleApiMultiUpdateReq) (*Response, error)
	RoleApiIndex(context.Context, *RoleApiIndexReq) (*RoleApiIndexResp, error)
	mustEmbedUnimplementedRoleManageServer()
}

// UnimplementedRoleManageServer must be embedded to have forward compatible implementations.
type UnimplementedRoleManageServer struct {
}

func (UnimplementedRoleManageServer) RoleInfoCreate(context.Context, *RoleInfo) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RoleInfoCreate not implemented")
}
func (UnimplementedRoleManageServer) RoleInfoIndex(context.Context, *RoleInfoIndexReq) (*RoleInfoIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RoleInfoIndex not implemented")
}
func (UnimplementedRoleManageServer) RoleInfoUpdate(context.Context, *RoleInfo) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RoleInfoUpdate not implemented")
}
func (UnimplementedRoleManageServer) RoleInfoDelete(context.Context, *ReqWithID) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RoleInfoDelete not implemented")
}
func (UnimplementedRoleManageServer) RoleMenuIndex(context.Context, *RoleMenuIndexReq) (*RoleMenuIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RoleMenuIndex not implemented")
}
func (UnimplementedRoleManageServer) RoleMenuMultiUpdate(context.Context, *RoleMenuMultiUpdateReq) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RoleMenuMultiUpdate not implemented")
}
func (UnimplementedRoleManageServer) RoleAppIndex(context.Context, *RoleAppIndexReq) (*RoleAppIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RoleAppIndex not implemented")
}
func (UnimplementedRoleManageServer) RoleAppMultiUpdate(context.Context, *RoleAppMultiUpdateReq) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RoleAppMultiUpdate not implemented")
}
func (UnimplementedRoleManageServer) RoleApiAuth(context.Context, *RoleApiAuthReq) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RoleApiAuth not implemented")
}
func (UnimplementedRoleManageServer) RoleApiMultiUpdate(context.Context, *RoleApiMultiUpdateReq) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RoleApiMultiUpdate not implemented")
}
func (UnimplementedRoleManageServer) RoleApiIndex(context.Context, *RoleApiIndexReq) (*RoleApiIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RoleApiIndex not implemented")
}
func (UnimplementedRoleManageServer) mustEmbedUnimplementedRoleManageServer() {}

// UnsafeRoleManageServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RoleManageServer will
// result in compilation errors.
type UnsafeRoleManageServer interface {
	mustEmbedUnimplementedRoleManageServer()
}

func RegisterRoleManageServer(s grpc.ServiceRegistrar, srv RoleManageServer) {
	s.RegisterService(&RoleManage_ServiceDesc, srv)
}

func _RoleManage_RoleInfoCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoleInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleManageServer).RoleInfoCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoleManage_RoleInfoCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleManageServer).RoleInfoCreate(ctx, req.(*RoleInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoleManage_RoleInfoIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoleInfoIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleManageServer).RoleInfoIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoleManage_RoleInfoIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleManageServer).RoleInfoIndex(ctx, req.(*RoleInfoIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoleManage_RoleInfoUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoleInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleManageServer).RoleInfoUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoleManage_RoleInfoUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleManageServer).RoleInfoUpdate(ctx, req.(*RoleInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoleManage_RoleInfoDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqWithID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleManageServer).RoleInfoDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoleManage_RoleInfoDelete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleManageServer).RoleInfoDelete(ctx, req.(*ReqWithID))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoleManage_RoleMenuIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoleMenuIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleManageServer).RoleMenuIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoleManage_RoleMenuIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleManageServer).RoleMenuIndex(ctx, req.(*RoleMenuIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoleManage_RoleMenuMultiUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoleMenuMultiUpdateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleManageServer).RoleMenuMultiUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoleManage_RoleMenuMultiUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleManageServer).RoleMenuMultiUpdate(ctx, req.(*RoleMenuMultiUpdateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoleManage_RoleAppIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoleAppIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleManageServer).RoleAppIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoleManage_RoleAppIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleManageServer).RoleAppIndex(ctx, req.(*RoleAppIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoleManage_RoleAppMultiUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoleAppMultiUpdateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleManageServer).RoleAppMultiUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoleManage_RoleAppMultiUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleManageServer).RoleAppMultiUpdate(ctx, req.(*RoleAppMultiUpdateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoleManage_RoleApiAuth_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoleApiAuthReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleManageServer).RoleApiAuth(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoleManage_RoleApiAuth_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleManageServer).RoleApiAuth(ctx, req.(*RoleApiAuthReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoleManage_RoleApiMultiUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoleApiMultiUpdateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleManageServer).RoleApiMultiUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoleManage_RoleApiMultiUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleManageServer).RoleApiMultiUpdate(ctx, req.(*RoleApiMultiUpdateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _RoleManage_RoleApiIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RoleApiIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoleManageServer).RoleApiIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RoleManage_RoleApiIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoleManageServer).RoleApiIndex(ctx, req.(*RoleApiIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

// RoleManage_ServiceDesc is the grpc.ServiceDesc for RoleManage service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RoleManage_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sys.RoleManage",
	HandlerType: (*RoleManageServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "roleInfoCreate",
			Handler:    _RoleManage_RoleInfoCreate_Handler,
		},
		{
			MethodName: "roleInfoIndex",
			Handler:    _RoleManage_RoleInfoIndex_Handler,
		},
		{
			MethodName: "roleInfoUpdate",
			Handler:    _RoleManage_RoleInfoUpdate_Handler,
		},
		{
			MethodName: "roleInfoDelete",
			Handler:    _RoleManage_RoleInfoDelete_Handler,
		},
		{
			MethodName: "roleMenuIndex",
			Handler:    _RoleManage_RoleMenuIndex_Handler,
		},
		{
			MethodName: "roleMenuMultiUpdate",
			Handler:    _RoleManage_RoleMenuMultiUpdate_Handler,
		},
		{
			MethodName: "roleAppIndex",
			Handler:    _RoleManage_RoleAppIndex_Handler,
		},
		{
			MethodName: "roleAppMultiUpdate",
			Handler:    _RoleManage_RoleAppMultiUpdate_Handler,
		},
		{
			MethodName: "roleApiAuth",
			Handler:    _RoleManage_RoleApiAuth_Handler,
		},
		{
			MethodName: "roleApiMultiUpdate",
			Handler:    _RoleManage_RoleApiMultiUpdate_Handler,
		},
		{
			MethodName: "roleApiIndex",
			Handler:    _RoleManage_RoleApiIndex_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/sys.proto",
}

const (
	AppManage_AppInfoCreate_FullMethodName = "/sys.AppManage/appInfoCreate"
	AppManage_AppInfoIndex_FullMethodName  = "/sys.AppManage/appInfoIndex"
	AppManage_AppInfoUpdate_FullMethodName = "/sys.AppManage/appInfoUpdate"
	AppManage_AppInfoDelete_FullMethodName = "/sys.AppManage/appInfoDelete"
	AppManage_AppInfoRead_FullMethodName   = "/sys.AppManage/appInfoRead"
)

// AppManageClient is the client API for AppManage service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AppManageClient interface {
	AppInfoCreate(ctx context.Context, in *AppInfo, opts ...grpc.CallOption) (*Response, error)
	AppInfoIndex(ctx context.Context, in *AppInfoIndexReq, opts ...grpc.CallOption) (*AppInfoIndexResp, error)
	AppInfoUpdate(ctx context.Context, in *AppInfo, opts ...grpc.CallOption) (*Response, error)
	AppInfoDelete(ctx context.Context, in *ReqWithIDCode, opts ...grpc.CallOption) (*Response, error)
	AppInfoRead(ctx context.Context, in *ReqWithIDCode, opts ...grpc.CallOption) (*AppInfo, error)
}

type appManageClient struct {
	cc grpc.ClientConnInterface
}

func NewAppManageClient(cc grpc.ClientConnInterface) AppManageClient {
	return &appManageClient{cc}
}

func (c *appManageClient) AppInfoCreate(ctx context.Context, in *AppInfo, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, AppManage_AppInfoCreate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *appManageClient) AppInfoIndex(ctx context.Context, in *AppInfoIndexReq, opts ...grpc.CallOption) (*AppInfoIndexResp, error) {
	out := new(AppInfoIndexResp)
	err := c.cc.Invoke(ctx, AppManage_AppInfoIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *appManageClient) AppInfoUpdate(ctx context.Context, in *AppInfo, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, AppManage_AppInfoUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *appManageClient) AppInfoDelete(ctx context.Context, in *ReqWithIDCode, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, AppManage_AppInfoDelete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *appManageClient) AppInfoRead(ctx context.Context, in *ReqWithIDCode, opts ...grpc.CallOption) (*AppInfo, error) {
	out := new(AppInfo)
	err := c.cc.Invoke(ctx, AppManage_AppInfoRead_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AppManageServer is the server API for AppManage service.
// All implementations must embed UnimplementedAppManageServer
// for forward compatibility
type AppManageServer interface {
	AppInfoCreate(context.Context, *AppInfo) (*Response, error)
	AppInfoIndex(context.Context, *AppInfoIndexReq) (*AppInfoIndexResp, error)
	AppInfoUpdate(context.Context, *AppInfo) (*Response, error)
	AppInfoDelete(context.Context, *ReqWithIDCode) (*Response, error)
	AppInfoRead(context.Context, *ReqWithIDCode) (*AppInfo, error)
	mustEmbedUnimplementedAppManageServer()
}

// UnimplementedAppManageServer must be embedded to have forward compatible implementations.
type UnimplementedAppManageServer struct {
}

func (UnimplementedAppManageServer) AppInfoCreate(context.Context, *AppInfo) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AppInfoCreate not implemented")
}
func (UnimplementedAppManageServer) AppInfoIndex(context.Context, *AppInfoIndexReq) (*AppInfoIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AppInfoIndex not implemented")
}
func (UnimplementedAppManageServer) AppInfoUpdate(context.Context, *AppInfo) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AppInfoUpdate not implemented")
}
func (UnimplementedAppManageServer) AppInfoDelete(context.Context, *ReqWithIDCode) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AppInfoDelete not implemented")
}
func (UnimplementedAppManageServer) AppInfoRead(context.Context, *ReqWithIDCode) (*AppInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AppInfoRead not implemented")
}
func (UnimplementedAppManageServer) mustEmbedUnimplementedAppManageServer() {}

// UnsafeAppManageServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AppManageServer will
// result in compilation errors.
type UnsafeAppManageServer interface {
	mustEmbedUnimplementedAppManageServer()
}

func RegisterAppManageServer(s grpc.ServiceRegistrar, srv AppManageServer) {
	s.RegisterService(&AppManage_ServiceDesc, srv)
}

func _AppManage_AppInfoCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AppInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppManageServer).AppInfoCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AppManage_AppInfoCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppManageServer).AppInfoCreate(ctx, req.(*AppInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _AppManage_AppInfoIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AppInfoIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppManageServer).AppInfoIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AppManage_AppInfoIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppManageServer).AppInfoIndex(ctx, req.(*AppInfoIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _AppManage_AppInfoUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AppInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppManageServer).AppInfoUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AppManage_AppInfoUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppManageServer).AppInfoUpdate(ctx, req.(*AppInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _AppManage_AppInfoDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqWithIDCode)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppManageServer).AppInfoDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AppManage_AppInfoDelete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppManageServer).AppInfoDelete(ctx, req.(*ReqWithIDCode))
	}
	return interceptor(ctx, in, info, handler)
}

func _AppManage_AppInfoRead_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqWithIDCode)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AppManageServer).AppInfoRead(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AppManage_AppInfoRead_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AppManageServer).AppInfoRead(ctx, req.(*ReqWithIDCode))
	}
	return interceptor(ctx, in, info, handler)
}

// AppManage_ServiceDesc is the grpc.ServiceDesc for AppManage service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AppManage_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sys.AppManage",
	HandlerType: (*AppManageServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "appInfoCreate",
			Handler:    _AppManage_AppInfoCreate_Handler,
		},
		{
			MethodName: "appInfoIndex",
			Handler:    _AppManage_AppInfoIndex_Handler,
		},
		{
			MethodName: "appInfoUpdate",
			Handler:    _AppManage_AppInfoUpdate_Handler,
		},
		{
			MethodName: "appInfoDelete",
			Handler:    _AppManage_AppInfoDelete_Handler,
		},
		{
			MethodName: "appInfoRead",
			Handler:    _AppManage_AppInfoRead_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/sys.proto",
}

const (
	MenuManage_MenuInfoCreate_FullMethodName = "/sys.MenuManage/menuInfoCreate"
	MenuManage_MenuInfoIndex_FullMethodName  = "/sys.MenuManage/menuInfoIndex"
	MenuManage_MenuInfoUpdate_FullMethodName = "/sys.MenuManage/menuInfoUpdate"
	MenuManage_MenuInfoDelete_FullMethodName = "/sys.MenuManage/menuInfoDelete"
)

// MenuManageClient is the client API for MenuManage service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MenuManageClient interface {
	MenuInfoCreate(ctx context.Context, in *MenuInfo, opts ...grpc.CallOption) (*Response, error)
	MenuInfoIndex(ctx context.Context, in *MenuInfoIndexReq, opts ...grpc.CallOption) (*MenuInfoIndexResp, error)
	MenuInfoUpdate(ctx context.Context, in *MenuInfo, opts ...grpc.CallOption) (*Response, error)
	MenuInfoDelete(ctx context.Context, in *ReqWithID, opts ...grpc.CallOption) (*Response, error)
}

type menuManageClient struct {
	cc grpc.ClientConnInterface
}

func NewMenuManageClient(cc grpc.ClientConnInterface) MenuManageClient {
	return &menuManageClient{cc}
}

func (c *menuManageClient) MenuInfoCreate(ctx context.Context, in *MenuInfo, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, MenuManage_MenuInfoCreate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *menuManageClient) MenuInfoIndex(ctx context.Context, in *MenuInfoIndexReq, opts ...grpc.CallOption) (*MenuInfoIndexResp, error) {
	out := new(MenuInfoIndexResp)
	err := c.cc.Invoke(ctx, MenuManage_MenuInfoIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *menuManageClient) MenuInfoUpdate(ctx context.Context, in *MenuInfo, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, MenuManage_MenuInfoUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *menuManageClient) MenuInfoDelete(ctx context.Context, in *ReqWithID, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, MenuManage_MenuInfoDelete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MenuManageServer is the server API for MenuManage service.
// All implementations must embed UnimplementedMenuManageServer
// for forward compatibility
type MenuManageServer interface {
	MenuInfoCreate(context.Context, *MenuInfo) (*Response, error)
	MenuInfoIndex(context.Context, *MenuInfoIndexReq) (*MenuInfoIndexResp, error)
	MenuInfoUpdate(context.Context, *MenuInfo) (*Response, error)
	MenuInfoDelete(context.Context, *ReqWithID) (*Response, error)
	mustEmbedUnimplementedMenuManageServer()
}

// UnimplementedMenuManageServer must be embedded to have forward compatible implementations.
type UnimplementedMenuManageServer struct {
}

func (UnimplementedMenuManageServer) MenuInfoCreate(context.Context, *MenuInfo) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MenuInfoCreate not implemented")
}
func (UnimplementedMenuManageServer) MenuInfoIndex(context.Context, *MenuInfoIndexReq) (*MenuInfoIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MenuInfoIndex not implemented")
}
func (UnimplementedMenuManageServer) MenuInfoUpdate(context.Context, *MenuInfo) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MenuInfoUpdate not implemented")
}
func (UnimplementedMenuManageServer) MenuInfoDelete(context.Context, *ReqWithID) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MenuInfoDelete not implemented")
}
func (UnimplementedMenuManageServer) mustEmbedUnimplementedMenuManageServer() {}

// UnsafeMenuManageServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MenuManageServer will
// result in compilation errors.
type UnsafeMenuManageServer interface {
	mustEmbedUnimplementedMenuManageServer()
}

func RegisterMenuManageServer(s grpc.ServiceRegistrar, srv MenuManageServer) {
	s.RegisterService(&MenuManage_ServiceDesc, srv)
}

func _MenuManage_MenuInfoCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MenuInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MenuManageServer).MenuInfoCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MenuManage_MenuInfoCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MenuManageServer).MenuInfoCreate(ctx, req.(*MenuInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _MenuManage_MenuInfoIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MenuInfoIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MenuManageServer).MenuInfoIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MenuManage_MenuInfoIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MenuManageServer).MenuInfoIndex(ctx, req.(*MenuInfoIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _MenuManage_MenuInfoUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MenuInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MenuManageServer).MenuInfoUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MenuManage_MenuInfoUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MenuManageServer).MenuInfoUpdate(ctx, req.(*MenuInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _MenuManage_MenuInfoDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqWithID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MenuManageServer).MenuInfoDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MenuManage_MenuInfoDelete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MenuManageServer).MenuInfoDelete(ctx, req.(*ReqWithID))
	}
	return interceptor(ctx, in, info, handler)
}

// MenuManage_ServiceDesc is the grpc.ServiceDesc for MenuManage service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MenuManage_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sys.MenuManage",
	HandlerType: (*MenuManageServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "menuInfoCreate",
			Handler:    _MenuManage_MenuInfoCreate_Handler,
		},
		{
			MethodName: "menuInfoIndex",
			Handler:    _MenuManage_MenuInfoIndex_Handler,
		},
		{
			MethodName: "menuInfoUpdate",
			Handler:    _MenuManage_MenuInfoUpdate_Handler,
		},
		{
			MethodName: "menuInfoDelete",
			Handler:    _MenuManage_MenuInfoDelete_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/sys.proto",
}

const (
	Common_Config_FullMethodName = "/sys.Common/config"
)

// CommonClient is the client API for Common service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CommonClient interface {
	Config(ctx context.Context, in *Response, opts ...grpc.CallOption) (*ConfigResp, error)
}

type commonClient struct {
	cc grpc.ClientConnInterface
}

func NewCommonClient(cc grpc.ClientConnInterface) CommonClient {
	return &commonClient{cc}
}

func (c *commonClient) Config(ctx context.Context, in *Response, opts ...grpc.CallOption) (*ConfigResp, error) {
	out := new(ConfigResp)
	err := c.cc.Invoke(ctx, Common_Config_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CommonServer is the server API for Common service.
// All implementations must embed UnimplementedCommonServer
// for forward compatibility
type CommonServer interface {
	Config(context.Context, *Response) (*ConfigResp, error)
	mustEmbedUnimplementedCommonServer()
}

// UnimplementedCommonServer must be embedded to have forward compatible implementations.
type UnimplementedCommonServer struct {
}

func (UnimplementedCommonServer) Config(context.Context, *Response) (*ConfigResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Config not implemented")
}
func (UnimplementedCommonServer) mustEmbedUnimplementedCommonServer() {}

// UnsafeCommonServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CommonServer will
// result in compilation errors.
type UnsafeCommonServer interface {
	mustEmbedUnimplementedCommonServer()
}

func RegisterCommonServer(s grpc.ServiceRegistrar, srv CommonServer) {
	s.RegisterService(&Common_ServiceDesc, srv)
}

func _Common_Config_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Response)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommonServer).Config(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Common_Config_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommonServer).Config(ctx, req.(*Response))
	}
	return interceptor(ctx, in, info, handler)
}

// Common_ServiceDesc is the grpc.ServiceDesc for Common service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Common_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sys.Common",
	HandlerType: (*CommonServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "config",
			Handler:    _Common_Config_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/sys.proto",
}

const (
	Log_LoginLogIndex_FullMethodName  = "/sys.Log/loginLogIndex"
	Log_OperLogIndex_FullMethodName   = "/sys.Log/operLogIndex"
	Log_LoginLogCreate_FullMethodName = "/sys.Log/loginLogCreate"
	Log_OperLogCreate_FullMethodName  = "/sys.Log/operLogCreate"
)

// LogClient is the client API for Log service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type LogClient interface {
	LoginLogIndex(ctx context.Context, in *LoginLogIndexReq, opts ...grpc.CallOption) (*LoginLogIndexResp, error)
	OperLogIndex(ctx context.Context, in *OperLogIndexReq, opts ...grpc.CallOption) (*OperLogIndexResp, error)
	LoginLogCreate(ctx context.Context, in *LoginLogCreateReq, opts ...grpc.CallOption) (*Response, error)
	OperLogCreate(ctx context.Context, in *OperLogCreateReq, opts ...grpc.CallOption) (*Response, error)
}

type logClient struct {
	cc grpc.ClientConnInterface
}

func NewLogClient(cc grpc.ClientConnInterface) LogClient {
	return &logClient{cc}
}

func (c *logClient) LoginLogIndex(ctx context.Context, in *LoginLogIndexReq, opts ...grpc.CallOption) (*LoginLogIndexResp, error) {
	out := new(LoginLogIndexResp)
	err := c.cc.Invoke(ctx, Log_LoginLogIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *logClient) OperLogIndex(ctx context.Context, in *OperLogIndexReq, opts ...grpc.CallOption) (*OperLogIndexResp, error) {
	out := new(OperLogIndexResp)
	err := c.cc.Invoke(ctx, Log_OperLogIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *logClient) LoginLogCreate(ctx context.Context, in *LoginLogCreateReq, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, Log_LoginLogCreate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *logClient) OperLogCreate(ctx context.Context, in *OperLogCreateReq, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, Log_OperLogCreate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LogServer is the server API for Log service.
// All implementations must embed UnimplementedLogServer
// for forward compatibility
type LogServer interface {
	LoginLogIndex(context.Context, *LoginLogIndexReq) (*LoginLogIndexResp, error)
	OperLogIndex(context.Context, *OperLogIndexReq) (*OperLogIndexResp, error)
	LoginLogCreate(context.Context, *LoginLogCreateReq) (*Response, error)
	OperLogCreate(context.Context, *OperLogCreateReq) (*Response, error)
	mustEmbedUnimplementedLogServer()
}

// UnimplementedLogServer must be embedded to have forward compatible implementations.
type UnimplementedLogServer struct {
}

func (UnimplementedLogServer) LoginLogIndex(context.Context, *LoginLogIndexReq) (*LoginLogIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LoginLogIndex not implemented")
}
func (UnimplementedLogServer) OperLogIndex(context.Context, *OperLogIndexReq) (*OperLogIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OperLogIndex not implemented")
}
func (UnimplementedLogServer) LoginLogCreate(context.Context, *LoginLogCreateReq) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LoginLogCreate not implemented")
}
func (UnimplementedLogServer) OperLogCreate(context.Context, *OperLogCreateReq) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OperLogCreate not implemented")
}
func (UnimplementedLogServer) mustEmbedUnimplementedLogServer() {}

// UnsafeLogServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LogServer will
// result in compilation errors.
type UnsafeLogServer interface {
	mustEmbedUnimplementedLogServer()
}

func RegisterLogServer(s grpc.ServiceRegistrar, srv LogServer) {
	s.RegisterService(&Log_ServiceDesc, srv)
}

func _Log_LoginLogIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoginLogIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LogServer).LoginLogIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Log_LoginLogIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LogServer).LoginLogIndex(ctx, req.(*LoginLogIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Log_OperLogIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OperLogIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LogServer).OperLogIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Log_OperLogIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LogServer).OperLogIndex(ctx, req.(*OperLogIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Log_LoginLogCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoginLogCreateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LogServer).LoginLogCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Log_LoginLogCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LogServer).LoginLogCreate(ctx, req.(*LoginLogCreateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Log_OperLogCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OperLogCreateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LogServer).OperLogCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Log_OperLogCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LogServer).OperLogCreate(ctx, req.(*OperLogCreateReq))
	}
	return interceptor(ctx, in, info, handler)
}

// Log_ServiceDesc is the grpc.ServiceDesc for Log service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Log_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sys.Log",
	HandlerType: (*LogServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "loginLogIndex",
			Handler:    _Log_LoginLogIndex_Handler,
		},
		{
			MethodName: "operLogIndex",
			Handler:    _Log_OperLogIndex_Handler,
		},
		{
			MethodName: "loginLogCreate",
			Handler:    _Log_LoginLogCreate_Handler,
		},
		{
			MethodName: "operLogCreate",
			Handler:    _Log_OperLogCreate_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/sys.proto",
}

const (
	ApiManage_ApiInfoCreate_FullMethodName = "/sys.ApiManage/apiInfoCreate"
	ApiManage_ApiInfoIndex_FullMethodName  = "/sys.ApiManage/apiInfoIndex"
	ApiManage_ApiInfoUpdate_FullMethodName = "/sys.ApiManage/apiInfoUpdate"
	ApiManage_ApiInfoDelete_FullMethodName = "/sys.ApiManage/apiInfoDelete"
)

// ApiManageClient is the client API for ApiManage service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ApiManageClient interface {
	ApiInfoCreate(ctx context.Context, in *ApiInfo, opts ...grpc.CallOption) (*Response, error)
	ApiInfoIndex(ctx context.Context, in *ApiInfoIndexReq, opts ...grpc.CallOption) (*ApiInfoIndexResp, error)
	ApiInfoUpdate(ctx context.Context, in *ApiInfo, opts ...grpc.CallOption) (*Response, error)
	ApiInfoDelete(ctx context.Context, in *ReqWithID, opts ...grpc.CallOption) (*Response, error)
}

type apiManageClient struct {
	cc grpc.ClientConnInterface
}

func NewApiManageClient(cc grpc.ClientConnInterface) ApiManageClient {
	return &apiManageClient{cc}
}

func (c *apiManageClient) ApiInfoCreate(ctx context.Context, in *ApiInfo, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, ApiManage_ApiInfoCreate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiManageClient) ApiInfoIndex(ctx context.Context, in *ApiInfoIndexReq, opts ...grpc.CallOption) (*ApiInfoIndexResp, error) {
	out := new(ApiInfoIndexResp)
	err := c.cc.Invoke(ctx, ApiManage_ApiInfoIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiManageClient) ApiInfoUpdate(ctx context.Context, in *ApiInfo, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, ApiManage_ApiInfoUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *apiManageClient) ApiInfoDelete(ctx context.Context, in *ReqWithID, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, ApiManage_ApiInfoDelete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ApiManageServer is the server API for ApiManage service.
// All implementations must embed UnimplementedApiManageServer
// for forward compatibility
type ApiManageServer interface {
	ApiInfoCreate(context.Context, *ApiInfo) (*Response, error)
	ApiInfoIndex(context.Context, *ApiInfoIndexReq) (*ApiInfoIndexResp, error)
	ApiInfoUpdate(context.Context, *ApiInfo) (*Response, error)
	ApiInfoDelete(context.Context, *ReqWithID) (*Response, error)
	mustEmbedUnimplementedApiManageServer()
}

// UnimplementedApiManageServer must be embedded to have forward compatible implementations.
type UnimplementedApiManageServer struct {
}

func (UnimplementedApiManageServer) ApiInfoCreate(context.Context, *ApiInfo) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ApiInfoCreate not implemented")
}
func (UnimplementedApiManageServer) ApiInfoIndex(context.Context, *ApiInfoIndexReq) (*ApiInfoIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ApiInfoIndex not implemented")
}
func (UnimplementedApiManageServer) ApiInfoUpdate(context.Context, *ApiInfo) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ApiInfoUpdate not implemented")
}
func (UnimplementedApiManageServer) ApiInfoDelete(context.Context, *ReqWithID) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ApiInfoDelete not implemented")
}
func (UnimplementedApiManageServer) mustEmbedUnimplementedApiManageServer() {}

// UnsafeApiManageServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ApiManageServer will
// result in compilation errors.
type UnsafeApiManageServer interface {
	mustEmbedUnimplementedApiManageServer()
}

func RegisterApiManageServer(s grpc.ServiceRegistrar, srv ApiManageServer) {
	s.RegisterService(&ApiManage_ServiceDesc, srv)
}

func _ApiManage_ApiInfoCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApiInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiManageServer).ApiInfoCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ApiManage_ApiInfoCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiManageServer).ApiInfoCreate(ctx, req.(*ApiInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiManage_ApiInfoIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApiInfoIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiManageServer).ApiInfoIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ApiManage_ApiInfoIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiManageServer).ApiInfoIndex(ctx, req.(*ApiInfoIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiManage_ApiInfoUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApiInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiManageServer).ApiInfoUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ApiManage_ApiInfoUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiManageServer).ApiInfoUpdate(ctx, req.(*ApiInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _ApiManage_ApiInfoDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqWithID)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ApiManageServer).ApiInfoDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ApiManage_ApiInfoDelete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ApiManageServer).ApiInfoDelete(ctx, req.(*ReqWithID))
	}
	return interceptor(ctx, in, info, handler)
}

// ApiManage_ServiceDesc is the grpc.ServiceDesc for ApiManage service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ApiManage_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sys.ApiManage",
	HandlerType: (*ApiManageServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "apiInfoCreate",
			Handler:    _ApiManage_ApiInfoCreate_Handler,
		},
		{
			MethodName: "apiInfoIndex",
			Handler:    _ApiManage_ApiInfoIndex_Handler,
		},
		{
			MethodName: "apiInfoUpdate",
			Handler:    _ApiManage_ApiInfoUpdate_Handler,
		},
		{
			MethodName: "apiInfoDelete",
			Handler:    _ApiManage_ApiInfoDelete_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/sys.proto",
}

const (
	ProjectManage_ProjectInfoCreate_FullMethodName = "/sys.ProjectManage/projectInfoCreate"
	ProjectManage_ProjectInfoUpdate_FullMethodName = "/sys.ProjectManage/projectInfoUpdate"
	ProjectManage_ProjectInfoDelete_FullMethodName = "/sys.ProjectManage/projectInfoDelete"
	ProjectManage_ProjectInfoRead_FullMethodName   = "/sys.ProjectManage/projectInfoRead"
	ProjectManage_ProjectInfoIndex_FullMethodName  = "/sys.ProjectManage/projectInfoIndex"
)

// ProjectManageClient is the client API for ProjectManage service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ProjectManageClient interface {
	// 
	ProjectInfoCreate(ctx context.Context, in *ProjectInfo, opts ...grpc.CallOption) (*Response, error)
	// 
	ProjectInfoUpdate(ctx context.Context, in *ProjectInfo, opts ...grpc.CallOption) (*Response, error)
	// 
	ProjectInfoDelete(ctx context.Context, in *ProjectInfoDeleteReq, opts ...grpc.CallOption) (*Response, error)
	// 
	ProjectInfoRead(ctx context.Context, in *ProjectInfoReadReq, opts ...grpc.CallOption) (*ProjectInfo, error)
	// 
	ProjectInfoIndex(ctx context.Context, in *ProjectInfoIndexReq, opts ...grpc.CallOption) (*ProjectInfoIndexResp, error)
}

type projectManageClient struct {
	cc grpc.ClientConnInterface
}

func NewProjectManageClient(cc grpc.ClientConnInterface) ProjectManageClient {
	return &projectManageClient{cc}
}

func (c *projectManageClient) ProjectInfoCreate(ctx context.Context, in *ProjectInfo, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, ProjectManage_ProjectInfoCreate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectManageClient) ProjectInfoUpdate(ctx context.Context, in *ProjectInfo, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, ProjectManage_ProjectInfoUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectManageClient) ProjectInfoDelete(ctx context.Context, in *ProjectInfoDeleteReq, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, ProjectManage_ProjectInfoDelete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectManageClient) ProjectInfoRead(ctx context.Context, in *ProjectInfoReadReq, opts ...grpc.CallOption) (*ProjectInfo, error) {
	out := new(ProjectInfo)
	err := c.cc.Invoke(ctx, ProjectManage_ProjectInfoRead_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectManageClient) ProjectInfoIndex(ctx context.Context, in *ProjectInfoIndexReq, opts ...grpc.CallOption) (*ProjectInfoIndexResp, error) {
	out := new(ProjectInfoIndexResp)
	err := c.cc.Invoke(ctx, ProjectManage_ProjectInfoIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ProjectManageServer is the server API for ProjectManage service.
// All implementations must embed UnimplementedProjectManageServer
// for forward compatibility
type ProjectManageServer interface {
	// 
	ProjectInfoCreate(context.Context, *ProjectInfo) (*Response, error)
	// 
	ProjectInfoUpdate(context.Context, *ProjectInfo) (*Response, error)
	// 
	ProjectInfoDelete(context.Context, *ProjectInfoDeleteReq) (*Response, error)
	// 
	ProjectInfoRead(context.Context, *ProjectInfoReadReq) (*ProjectInfo, error)
	// 
	ProjectInfoIndex(context.Context, *ProjectInfoIndexReq) (*ProjectInfoIndexResp, error)
	mustEmbedUnimplementedProjectManageServer()
}

// UnimplementedProjectManageServer must be embedded to have forward compatible implementations.
type UnimplementedProjectManageServer struct {
}

func (UnimplementedProjectManageServer) ProjectInfoCreate(context.Context, *ProjectInfo) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProjectInfoCreate not implemented")
}
func (UnimplementedProjectManageServer) ProjectInfoUpdate(context.Context, *ProjectInfo) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProjectInfoUpdate not implemented")
}
func (UnimplementedProjectManageServer) ProjectInfoDelete(context.Context, *ProjectInfoDeleteReq) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProjectInfoDelete not implemented")
}
func (UnimplementedProjectManageServer) ProjectInfoRead(context.Context, *ProjectInfoReadReq) (*ProjectInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProjectInfoRead not implemented")
}
func (UnimplementedProjectManageServer) ProjectInfoIndex(context.Context, *ProjectInfoIndexReq) (*ProjectInfoIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProjectInfoIndex not implemented")
}
func (UnimplementedProjectManageServer) mustEmbedUnimplementedProjectManageServer() {}

// UnsafeProjectManageServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ProjectManageServer will
// result in compilation errors.
type UnsafeProjectManageServer interface {
	mustEmbedUnimplementedProjectManageServer()
}

func RegisterProjectManageServer(s grpc.ServiceRegistrar, srv ProjectManageServer) {
	s.RegisterService(&ProjectManage_ServiceDesc, srv)
}

func _ProjectManage_ProjectInfoCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProjectInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectManageServer).ProjectInfoCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProjectManage_ProjectInfoCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectManageServer).ProjectInfoCreate(ctx, req.(*ProjectInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProjectManage_ProjectInfoUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProjectInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectManageServer).ProjectInfoUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProjectManage_ProjectInfoUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectManageServer).ProjectInfoUpdate(ctx, req.(*ProjectInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProjectManage_ProjectInfoDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProjectInfoDeleteReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectManageServer).ProjectInfoDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProjectManage_ProjectInfoDelete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectManageServer).ProjectInfoDelete(ctx, req.(*ProjectInfoDeleteReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProjectManage_ProjectInfoRead_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProjectInfoReadReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectManageServer).ProjectInfoRead(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProjectManage_ProjectInfoRead_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectManageServer).ProjectInfoRead(ctx, req.(*ProjectInfoReadReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProjectManage_ProjectInfoIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProjectInfoIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectManageServer).ProjectInfoIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProjectManage_ProjectInfoIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectManageServer).ProjectInfoIndex(ctx, req.(*ProjectInfoIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

// ProjectManage_ServiceDesc is the grpc.ServiceDesc for ProjectManage service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ProjectManage_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sys.ProjectManage",
	HandlerType: (*ProjectManageServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "projectInfoCreate",
			Handler:    _ProjectManage_ProjectInfoCreate_Handler,
		},
		{
			MethodName: "projectInfoUpdate",
			Handler:    _ProjectManage_ProjectInfoUpdate_Handler,
		},
		{
			MethodName: "projectInfoDelete",
			Handler:    _ProjectManage_ProjectInfoDelete_Handler,
		},
		{
			MethodName: "projectInfoRead",
			Handler:    _ProjectManage_ProjectInfoRead_Handler,
		},
		{
			MethodName: "projectInfoIndex",
			Handler:    _ProjectManage_ProjectInfoIndex_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/sys.proto",
}

const (
	AreaManage_AreaInfoCreate_FullMethodName = "/sys.AreaManage/areaInfoCreate"
	AreaManage_AreaInfoUpdate_FullMethodName = "/sys.AreaManage/areaInfoUpdate"
	AreaManage_AreaInfoDelete_FullMethodName = "/sys.AreaManage/areaInfoDelete"
	AreaManage_AreaInfoRead_FullMethodName   = "/sys.AreaManage/areaInfoRead"
	AreaManage_AreaInfoIndex_FullMethodName  = "/sys.AreaManage/areaInfoIndex"
	AreaManage_AreaInfoTree_FullMethodName   = "/sys.AreaManage/areaInfoTree"
)

// AreaManageClient is the client API for AreaManage service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AreaManageClient interface {
	// 
	AreaInfoCreate(ctx context.Context, in *AreaInfo, opts ...grpc.CallOption) (*Response, error)
	// 
	AreaInfoUpdate(ctx context.Context, in *AreaInfo, opts ...grpc.CallOption) (*Response, error)
	// 
	AreaInfoDelete(ctx context.Context, in *AreaInfoDeleteReq, opts ...grpc.CallOption) (*Response, error)
	// 
	AreaInfoRead(ctx context.Context, in *AreaInfoReadReq, opts ...grpc.CallOption) (*AreaInfo, error)
	// 
	AreaInfoIndex(ctx context.Context, in *AreaInfoIndexReq, opts ...grpc.CallOption) (*AreaInfoIndexResp, error)
	// 
	AreaInfoTree(ctx context.Context, in *AreaInfoTreeReq, opts ...grpc.CallOption) (*AreaInfoTreeResp, error)
}

type areaManageClient struct {
	cc grpc.ClientConnInterface
}

func NewAreaManageClient(cc grpc.ClientConnInterface) AreaManageClient {
	return &areaManageClient{cc}
}

func (c *areaManageClient) AreaInfoCreate(ctx context.Context, in *AreaInfo, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, AreaManage_AreaInfoCreate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *areaManageClient) AreaInfoUpdate(ctx context.Context, in *AreaInfo, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, AreaManage_AreaInfoUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *areaManageClient) AreaInfoDelete(ctx context.Context, in *AreaInfoDeleteReq, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, AreaManage_AreaInfoDelete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *areaManageClient) AreaInfoRead(ctx context.Context, in *AreaInfoReadReq, opts ...grpc.CallOption) (*AreaInfo, error) {
	out := new(AreaInfo)
	err := c.cc.Invoke(ctx, AreaManage_AreaInfoRead_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *areaManageClient) AreaInfoIndex(ctx context.Context, in *AreaInfoIndexReq, opts ...grpc.CallOption) (*AreaInfoIndexResp, error) {
	out := new(AreaInfoIndexResp)
	err := c.cc.Invoke(ctx, AreaManage_AreaInfoIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *areaManageClient) AreaInfoTree(ctx context.Context, in *AreaInfoTreeReq, opts ...grpc.CallOption) (*AreaInfoTreeResp, error) {
	out := new(AreaInfoTreeResp)
	err := c.cc.Invoke(ctx, AreaManage_AreaInfoTree_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AreaManageServer is the server API for AreaManage service.
// All implementations must embed UnimplementedAreaManageServer
// for forward compatibility
type AreaManageServer interface {
	// 
	AreaInfoCreate(context.Context, *AreaInfo) (*Response, error)
	// 
	AreaInfoUpdate(context.Context, *AreaInfo) (*Response, error)
	// 
	AreaInfoDelete(context.Context, *AreaInfoDeleteReq) (*Response, error)
	// 
	AreaInfoRead(context.Context, *AreaInfoReadReq) (*AreaInfo, error)
	// 
	AreaInfoIndex(context.Context, *AreaInfoIndexReq) (*AreaInfoIndexResp, error)
	// 
	AreaInfoTree(context.Context, *AreaInfoTreeReq) (*AreaInfoTreeResp, error)
	mustEmbedUnimplementedAreaManageServer()
}

// UnimplementedAreaManageServer must be embedded to have forward compatible implementations.
type UnimplementedAreaManageServer struct {
}

func (UnimplementedAreaManageServer) AreaInfoCreate(context.Context, *AreaInfo) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AreaInfoCreate not implemented")
}
func (UnimplementedAreaManageServer) AreaInfoUpdate(context.Context, *AreaInfo) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AreaInfoUpdate not implemented")
}
func (UnimplementedAreaManageServer) AreaInfoDelete(context.Context, *AreaInfoDeleteReq) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AreaInfoDelete not implemented")
}
func (UnimplementedAreaManageServer) AreaInfoRead(context.Context, *AreaInfoReadReq) (*AreaInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AreaInfoRead not implemented")
}
func (UnimplementedAreaManageServer) AreaInfoIndex(context.Context, *AreaInfoIndexReq) (*AreaInfoIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AreaInfoIndex not implemented")
}
func (UnimplementedAreaManageServer) AreaInfoTree(context.Context, *AreaInfoTreeReq) (*AreaInfoTreeResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AreaInfoTree not implemented")
}
func (UnimplementedAreaManageServer) mustEmbedUnimplementedAreaManageServer() {}

// UnsafeAreaManageServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AreaManageServer will
// result in compilation errors.
type UnsafeAreaManageServer interface {
	mustEmbedUnimplementedAreaManageServer()
}

func RegisterAreaManageServer(s grpc.ServiceRegistrar, srv AreaManageServer) {
	s.RegisterService(&AreaManage_ServiceDesc, srv)
}

func _AreaManage_AreaInfoCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AreaInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AreaManageServer).AreaInfoCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AreaManage_AreaInfoCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AreaManageServer).AreaInfoCreate(ctx, req.(*AreaInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _AreaManage_AreaInfoUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AreaInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AreaManageServer).AreaInfoUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AreaManage_AreaInfoUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AreaManageServer).AreaInfoUpdate(ctx, req.(*AreaInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _AreaManage_AreaInfoDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AreaInfoDeleteReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AreaManageServer).AreaInfoDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AreaManage_AreaInfoDelete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AreaManageServer).AreaInfoDelete(ctx, req.(*AreaInfoDeleteReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _AreaManage_AreaInfoRead_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AreaInfoReadReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AreaManageServer).AreaInfoRead(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AreaManage_AreaInfoRead_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AreaManageServer).AreaInfoRead(ctx, req.(*AreaInfoReadReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _AreaManage_AreaInfoIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AreaInfoIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AreaManageServer).AreaInfoIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AreaManage_AreaInfoIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AreaManageServer).AreaInfoIndex(ctx, req.(*AreaInfoIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _AreaManage_AreaInfoTree_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AreaInfoTreeReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AreaManageServer).AreaInfoTree(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AreaManage_AreaInfoTree_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AreaManageServer).AreaInfoTree(ctx, req.(*AreaInfoTreeReq))
	}
	return interceptor(ctx, in, info, handler)
}

// AreaManage_ServiceDesc is the grpc.ServiceDesc for AreaManage service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AreaManage_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sys.AreaManage",
	HandlerType: (*AreaManageServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "areaInfoCreate",
			Handler:    _AreaManage_AreaInfoCreate_Handler,
		},
		{
			MethodName: "areaInfoUpdate",
			Handler:    _AreaManage_AreaInfoUpdate_Handler,
		},
		{
			MethodName: "areaInfoDelete",
			Handler:    _AreaManage_AreaInfoDelete_Handler,
		},
		{
			MethodName: "areaInfoRead",
			Handler:    _AreaManage_AreaInfoRead_Handler,
		},
		{
			MethodName: "areaInfoIndex",
			Handler:    _AreaManage_AreaInfoIndex_Handler,
		},
		{
			MethodName: "areaInfoTree",
			Handler:    _AreaManage_AreaInfoTree_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/sys.proto",
}

const (
	TenantManage_TenantInfoCreate_FullMethodName     = "/sys.TenantManage/tenantInfoCreate"
	TenantManage_TenantInfoUpdate_FullMethodName     = "/sys.TenantManage/tenantInfoUpdate"
	TenantManage_TenantInfoDelete_FullMethodName     = "/sys.TenantManage/tenantInfoDelete"
	TenantManage_TenantInfoRead_FullMethodName       = "/sys.TenantManage/tenantInfoRead"
	TenantManage_TenantInfoIndex_FullMethodName      = "/sys.TenantManage/tenantInfoIndex"
	TenantManage_TenantAppIndex_FullMethodName       = "/sys.TenantManage/tenantAppIndex"
	TenantManage_TenantAppMultiUpdate_FullMethodName = "/sys.TenantManage/tenantAppMultiUpdate"
)

// TenantManageClient is the client API for TenantManage service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TenantManageClient interface {
	// 
	TenantInfoCreate(ctx context.Context, in *TenantInfo, opts ...grpc.CallOption) (*Response, error)
	// 
	TenantInfoUpdate(ctx context.Context, in *TenantInfo, opts ...grpc.CallOption) (*Response, error)
	// 
	TenantInfoDelete(ctx context.Context, in *ReqWithIDCode, opts ...grpc.CallOption) (*Response, error)
	// 
	TenantInfoRead(ctx context.Context, in *ReqWithIDCode, opts ...grpc.CallOption) (*TenantInfo, error)
	// 
	TenantInfoIndex(ctx context.Context, in *TenantInfoIndexReq, opts ...grpc.CallOption) (*TenantInfoIndexResp, error)
	TenantAppIndex(ctx context.Context, in *TenantAppIndexReq, opts ...grpc.CallOption) (*TenantAppIndexResp, error)
	TenantAppMultiUpdate(ctx context.Context, in *TenantAppMultiUpdateReq, opts ...grpc.CallOption) (*Response, error)
}

type tenantManageClient struct {
	cc grpc.ClientConnInterface
}

func NewTenantManageClient(cc grpc.ClientConnInterface) TenantManageClient {
	return &tenantManageClient{cc}
}

func (c *tenantManageClient) TenantInfoCreate(ctx context.Context, in *TenantInfo, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, TenantManage_TenantInfoCreate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantManageClient) TenantInfoUpdate(ctx context.Context, in *TenantInfo, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, TenantManage_TenantInfoUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantManageClient) TenantInfoDelete(ctx context.Context, in *ReqWithIDCode, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, TenantManage_TenantInfoDelete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantManageClient) TenantInfoRead(ctx context.Context, in *ReqWithIDCode, opts ...grpc.CallOption) (*TenantInfo, error) {
	out := new(TenantInfo)
	err := c.cc.Invoke(ctx, TenantManage_TenantInfoRead_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantManageClient) TenantInfoIndex(ctx context.Context, in *TenantInfoIndexReq, opts ...grpc.CallOption) (*TenantInfoIndexResp, error) {
	out := new(TenantInfoIndexResp)
	err := c.cc.Invoke(ctx, TenantManage_TenantInfoIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantManageClient) TenantAppIndex(ctx context.Context, in *TenantAppIndexReq, opts ...grpc.CallOption) (*TenantAppIndexResp, error) {
	out := new(TenantAppIndexResp)
	err := c.cc.Invoke(ctx, TenantManage_TenantAppIndex_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tenantManageClient) TenantAppMultiUpdate(ctx context.Context, in *TenantAppMultiUpdateReq, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, TenantManage_TenantAppMultiUpdate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TenantManageServer is the server API for TenantManage service.
// All implementations must embed UnimplementedTenantManageServer
// for forward compatibility
type TenantManageServer interface {
	// 
	TenantInfoCreate(context.Context, *TenantInfo) (*Response, error)
	// 
	TenantInfoUpdate(context.Context, *TenantInfo) (*Response, error)
	// 
	TenantInfoDelete(context.Context, *ReqWithIDCode) (*Response, error)
	// 
	TenantInfoRead(context.Context, *ReqWithIDCode) (*TenantInfo, error)
	// 
	TenantInfoIndex(context.Context, *TenantInfoIndexReq) (*TenantInfoIndexResp, error)
	TenantAppIndex(context.Context, *TenantAppIndexReq) (*TenantAppIndexResp, error)
	TenantAppMultiUpdate(context.Context, *TenantAppMultiUpdateReq) (*Response, error)
	mustEmbedUnimplementedTenantManageServer()
}

// UnimplementedTenantManageServer must be embedded to have forward compatible implementations.
type UnimplementedTenantManageServer struct {
}

func (UnimplementedTenantManageServer) TenantInfoCreate(context.Context, *TenantInfo) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TenantInfoCreate not implemented")
}
func (UnimplementedTenantManageServer) TenantInfoUpdate(context.Context, *TenantInfo) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TenantInfoUpdate not implemented")
}
func (UnimplementedTenantManageServer) TenantInfoDelete(context.Context, *ReqWithIDCode) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TenantInfoDelete not implemented")
}
func (UnimplementedTenantManageServer) TenantInfoRead(context.Context, *ReqWithIDCode) (*TenantInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TenantInfoRead not implemented")
}
func (UnimplementedTenantManageServer) TenantInfoIndex(context.Context, *TenantInfoIndexReq) (*TenantInfoIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TenantInfoIndex not implemented")
}
func (UnimplementedTenantManageServer) TenantAppIndex(context.Context, *TenantAppIndexReq) (*TenantAppIndexResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TenantAppIndex not implemented")
}
func (UnimplementedTenantManageServer) TenantAppMultiUpdate(context.Context, *TenantAppMultiUpdateReq) (*Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TenantAppMultiUpdate not implemented")
}
func (UnimplementedTenantManageServer) mustEmbedUnimplementedTenantManageServer() {}

// UnsafeTenantManageServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TenantManageServer will
// result in compilation errors.
type UnsafeTenantManageServer interface {
	mustEmbedUnimplementedTenantManageServer()
}

func RegisterTenantManageServer(s grpc.ServiceRegistrar, srv TenantManageServer) {
	s.RegisterService(&TenantManage_ServiceDesc, srv)
}

func _TenantManage_TenantInfoCreate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TenantInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantManageServer).TenantInfoCreate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantManage_TenantInfoCreate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantManageServer).TenantInfoCreate(ctx, req.(*TenantInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantManage_TenantInfoUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TenantInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantManageServer).TenantInfoUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantManage_TenantInfoUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantManageServer).TenantInfoUpdate(ctx, req.(*TenantInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantManage_TenantInfoDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqWithIDCode)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantManageServer).TenantInfoDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantManage_TenantInfoDelete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantManageServer).TenantInfoDelete(ctx, req.(*ReqWithIDCode))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantManage_TenantInfoRead_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReqWithIDCode)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantManageServer).TenantInfoRead(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantManage_TenantInfoRead_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantManageServer).TenantInfoRead(ctx, req.(*ReqWithIDCode))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantManage_TenantInfoIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TenantInfoIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantManageServer).TenantInfoIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantManage_TenantInfoIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantManageServer).TenantInfoIndex(ctx, req.(*TenantInfoIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantManage_TenantAppIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TenantAppIndexReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantManageServer).TenantAppIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantManage_TenantAppIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantManageServer).TenantAppIndex(ctx, req.(*TenantAppIndexReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _TenantManage_TenantAppMultiUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TenantAppMultiUpdateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TenantManageServer).TenantAppMultiUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TenantManage_TenantAppMultiUpdate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TenantManageServer).TenantAppMultiUpdate(ctx, req.(*TenantAppMultiUpdateReq))
	}
	return interceptor(ctx, in, info, handler)
}

// TenantManage_ServiceDesc is the grpc.ServiceDesc for TenantManage service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TenantManage_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "sys.TenantManage",
	HandlerType: (*TenantManageServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "tenantInfoCreate",
			Handler:    _TenantManage_TenantInfoCreate_Handler,
		},
		{
			MethodName: "tenantInfoUpdate",
			Handler:    _TenantManage_TenantInfoUpdate_Handler,
		},
		{
			MethodName: "tenantInfoDelete",
			Handler:    _TenantManage_TenantInfoDelete_Handler,
		},
		{
			MethodName: "tenantInfoRead",
			Handler:    _TenantManage_TenantInfoRead_Handler,
		},
		{
			MethodName: "tenantInfoIndex",
			Handler:    _TenantManage_TenantInfoIndex_Handler,
		},
		{
			MethodName: "tenantAppIndex",
			Handler:    _TenantManage_TenantAppIndex_Handler,
		},
		{
			MethodName: "tenantAppMultiUpdate",
			Handler:    _TenantManage_TenantAppMultiUpdate_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/sys.proto",
}
